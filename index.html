<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GitHub文件管理器</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="./宫格.cs">
    <link rel="stylesheet" href="./style.css">
    
   
        <script src="./js/果冻浸染.js"></script>
</head>

<body>

    <div id="authScreen">
        <div class="auth-header">
            <i class="fa fa-github"></i>
            <h1>GitHub文件管理器</h1>
            <p>您的安全企业文件门户</p>
        </div>
        <div class="auth-form">
            <input type="text" id="tokenInput" placeholder="输入GitHub访问令牌">
            <button id="authBtn">登录</button>
        </div>
    </div>
    <div id="app" class="hidden">
        <header>
            <div class="header-left">
                <i class="fa fa-github"></i>
                <h1 id="currentRepo">选择仓库</h1>

                <div id="branchSwitcherContainer" class="hidden"></div>
                <div id="pathNav"></div>
                <div id="pathNavContainer"></div>
            </div>

            <div class="header-right">
                
                <button id="mainMenuBtn" title="菜单">
                    <i class="fa fa-user-circle-o"></i>
                </button>
            </div>
                    
        </header>
                
        <main>
        
            <div id="toolbar" class="hidden">
                <div class="toolbar-left">
                    <input id="searchInput" placeholder="搜索文件/文件夹..." class="hidden">
                </div>
                <button id="searchToggleBtn" class="btn-icon" title="搜索">
                    <i class="fa fa-search"></i>
                </button>
                <button id="proxyQuickToggle" title="代理状态">
                    <i class="fa fa-power-off"></i>
                </button>
                <div class="toolbar-right">
                    <div class="custom-select-container">
                        <button id="sortToggleBtn" class="btn-icon" title="排序">
                            <i class="fa fa-sort"></i>
                        </button>
                        <div id="customSortDropdown" class="hidden custom-dropdown">
                            <div class="dropdown-item" data-value="name_asc">名称 A→Z</div>
                            <div class="dropdown-item" data-value="name_desc">名称 Z→A</div>
                            <div class="dropdown-item" data-value="time_desc">时间 最新优先</div>
                            <div class="dropdown-item" data-value="time_asc">时间 最旧优先</div>
                            <div class="dropdown-item" data-value="size_desc">大小 大→小</div>
                            <div class="dropdown-item" data-value="size_asc">大小 小→大</div>
                        </div>
                    </div>
                    <button id="viewToggleBtn" title="切换视图">
                        <i class="fa fa-th-large"></i>
                    </button>
                </div>
            </div>
            <div id="repoList">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
            </div>
            <div id="fileList" class="hidden">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
            </div>
        </main>
        <div id="renameModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3 id="renameTitle"><span class="modal-title-text">重命名</span><button class="btn-icon-sm"
                        onclick="el.renameModal.classList.add('hidden')" title="关闭"><i
                            class="fa fa-times"></i></button></h3>
                <input type="text" id="renameInput" value="" autocomplete="off">
                <div id="renameWarn" class="text-red-400"
                    style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;"></div>
                <div class="modal-buttons">
                    <button id="renameCancel" class="btn btn-cancel">取消</button>
                    <button id="renameConfirm" class="btn btn-primary" disabled>确认</button>
                </div>
            </div>
        </div>
        <div id="deleteModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3 id="deleteTitle"><span class="modal-title-text">确认删除</span><button class="btn-icon-sm"
                        onclick="el.deleteModal.classList.add('hidden')" title="关闭"><i
                            class="fa fa-times"></i></button></h3>
                <p id="deleteDesc"></p>
                <div class="modal-buttons">
                    <button id="deleteCancel" class="btn btn-cancel">取消</button>
                    <button id="deleteConfirm" class="btn btn-danger">确认删除</button>
                </div>
            </div>
        </div>
        <div id="editModal" class="hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 id="editFileName">编辑文件</h5>
                    <div style="display:flex; gap:0.4rem;">
                        <button id="toggleMaximizeModal" title="最大化">
                            <i class="fa fa-expand"></i>
                        </button>
                        <button id="closeEditModal">
                            <i class="fa fa-times"></i>
                        </button>
                    </div>
                </div>
                <div id="editStatus"></div>
                <div class="editor-container">
                    <div id="editorOverlay">
                        <div class="spinner-container">
                            <i class="fa fa-spinner fa-spin"></i>
                        </div>
                    </div>
                    <div id="saveNotification">
                        <i class="fa fa-check"></i> 保存成功
                    </div>
                    <textarea id="fileContent"></textarea>
                </div>
                <div class="modal-footer">
                    <button id="cancelEdit">取消</button>
                    <button id="saveEdit">保存修改</button>
                </div>
            </div>
        </div>
        <div id="modalOverlay" class="hidden">
            <div class="modal-content">
                <div id="modalContent"></div>
            </div>
        </div>
        <div id="contextMenu" class="hidden">
            <div id="contextMenuItems"></div>
        </div>
        <div id="toast" class="hidden">
            <span id="toastMessage"></span>
        </div>
        <input type="file" id="fileUploadInput" multiple class="hidden">
        <div id="mainMenuPopup" class="hidden">
            <div class="user-profile-header">
                <i id="userAvatarPlaceholder" class="fa fa-github"></i>
                <img id="userAvatar" src="" alt="User Avatar" class="hidden">
                <span id="userName">name</span>
            </div>
            <div class="menu-items-container">
                <button id="menuRepoList">
                    <i class="fa fa-list"></i> 仓库列表
                </button>
                <button id="menuProxySettings">
                    <i class="fa fa-plug"></i> 代理设置
                </button>
                 <button id="menuRefresh">
                    <i class="fa fa-refresh"></i> 刷新页面
                </button>
                <button id="menuClearCache">
                    <i class="fa fa-trash"></i> 清除缓存
                </button>
                <button id="menuLogout">
                    <i class="fa fa-sign-out"></i> 退出登录
                </button>
            </div>
        </div>
        <footer>
            <button id="backBtn" title="返回上级">
                <i class="fa fa-arrow-up"></i>
            </button>
            <button id="newFolderBtn" title="新建仓库">
                <i class="fa fa-plus"></i>
            </button>
            <button id="newFileBtn" title="新建文件">
                <i class="fa fa-file-o"></i>
            </button>
            <button id="uploadBtn" title="上传文件">
                <i class="fa fa-upload"></i>
            </button>
        </footer>
        <div id="mediaPreview" class="hidden">
            <img id="mediaPreviewImg" style="display:none;" alt="预览图片">
            <video id="mediaPreviewVideo" style="display:none;" controls></video>
        </div>
        <div id="createRepoModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3><span class="modal-title-text">新建仓库</span><button class="btn-icon-sm"
                        onclick="el.createRepoModal.classList.add('hidden')" title="关闭"><i
                            class="fa fa-times"></i></button></h3>
                <input id="createRepoNameInput" placeholder="输入仓库名称（仅支持英文、数字、连字符）">
                <div id="repoNameError" class="text-red-400"
                    style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;"></div>
                <textarea id="createRepoDescInput" placeholder="仓库描述（可选）"></textarea>
                <div class="checkbox-container">
                    <input type="checkbox" id="createRepoPrivate">
                    <label for="createRepoPrivate">公开仓库</label>
                </div>
                <div class="modal-buttons">
                    <button id="createRepoCancel" class="btn btn-cancel">取消</button>
                    <button id="createRepoConfirm" class="btn btn-primary" disabled>创建仓库</button>
                </div>
            </div>
        </div>
        <div id="createFolderModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3><span class="modal-title-text">新建文件夹</span><button class="btn-icon-sm"
                        onclick="el.createFolderModal.classList.add('hidden')" title="关闭"><i
                            class="fa fa-times"></i></button></h3>
                <input id="createFolderInput" placeholder="输入文件夹名称">
                <div class="modal-buttons">
                    <button id="createFolderCancel" class="btn btn-cancel">取消</button>
                    <button id="createFolderConfirm" class="btn btn-primary" disabled>确认</button>
                </div>
            </div>
        </div>
        <div id="createFileModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3><span class="modal-title-text">新建文件</span><button class="btn-icon-sm"
                        onclick="el.createFileModal.classList.add('hidden')" title="关闭"><i
                            class="fa fa-times"></i></button></h3>
                <input id="createFileNameInput" placeholder="输入文件名，如 example.txt">
                <textarea id="createFileContentInput" placeholder="文件内容（可选）"></textarea>
                <div class="modal-buttons">
                    <button id="createFileCancel" class="btn btn-cancel">取消</button>
                    <button id="createFileConfirm" class="btn btn-primary" disabled>确认</button>
                </div>
            </div>
        </div>
        <div id="createBranchModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3><span class="modal-title-text">新建分支</span><button class="btn-icon-sm"
                        onclick="el.createBranchModal.classList.add('hidden')" title="关闭"><i
                            class="fa fa-times"></i></button></h3>
                
                <div class="form-group">
                    <label for="createBranchNameInput">新分支名称:</label>
                    <input id="createBranchNameInput" placeholder="输入新分支名称">
                </div>
<div id="666" class="form-group">
    <label for="createBranchSource">基于分支:</label>
    <div class="branch-select-container">
        <select id="createBranchSource" class="custom-select"></select>
        <button id="deleteBranchBtn" class="btn-icon danger" title="删除所选分支">
            <i class="fa fa-trash"></i>
        </button>
    </div>
</div>

                <div class="modal-buttons">
    <button id="createBranchCancel" class="btn btn-cancel">取消</button>
    
    <button id="createBranchConfirm" class="btn btn-primary" disabled>创建分支</button>
</div>
            </div>
        </div>
        <div id="uploadPanel" class="hidden">
            <div id="uploadItems" class="scmz"></div>
        </div>
        <div id="proxySettingsModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3>
                    <span class="modal-title-text">代理设置</span>
                    <!-- 新增: 自动优选开关 -->
                    <button id="proxyAutoSelectToggle" class="btn-icon" title="点击切换自动选择最低延迟代理">
                        <i class="fa fa-magic"></i>
                    </button>
                    <button id="proxyGlobalEnableToggle" class="btn-icon" title="点击切换全局代理状态">
                        <i class="fa fa-power-off"></i>
                    </button>
                    <button id="proxyCancelSettingsBtn" class="btn-icon" title="关闭设置">
                        <i class="fa fa-times"></i>
                    </button>
                </h3>
                <div class="proxy-list" id="proxyListContainer">
                    <div class="empty-state" id="proxyListEmpty" style="padding:0.8rem;">
                        <i class="fa fa-plug"></i>
                        <p>暂无代理</p>
                    </div>
                </div>
                <div class="modal-buttons">
                    <button id="proxyClearAllBtn" class="btn-icon danger" title="清空所有代理(保留默认)">
                        <i class="fa fa-trash"></i>
                    </button>
                    <button id="proxyTestAllBtn" class="btn-icon" title="全部测试延迟">
                        <i class="fa fa-flash"></i>
                        <span class="spinner-small hidden" id="proxyTestAllSpinner"></span>
                    </button>
                    <button id="proxyAddBtn" class="btn-icon" title="添加代理">
                        <i class="fa fa-plus"></i>
                    </button>
                </div>
            </div>
        </div>
        <div id="addEditProxyModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3 id="addEditProxyTitle">
                    <span class="modal-title-text">添加代理</span>
                    <button class="btn-icon-sm" onclick="closeAddEditProxyModal()" title="关闭">
                        <i class="fa fa-times"></i>
                    </button>

                </h3>
                <input id="addEditProxyUrlInput" type="url" placeholder="请输入代理域名"
                    autocomplete="off">
                <div id="addEditProxyError" class="text-red-400"
                    style="font-size: 0.4rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;"></div>

                <div class="proxy-type-selection">
                    <label>代理类型：</label>
                    <div class="proxy-type-display">
                        <span id="autoDetectedProxyType">保存时将自动测试并确定</span> <i class="fa fa-check"></i>
                    </div>
                </div>
                <div class="modal-buttons" style="margin-top:0.6rem;">
                    <button id="addEditProxySaveBtn" class="btn btn-primary" disabled>保存</button>
                </div>
            </div>
        </div>
        <div id="confirmDeleteProxyModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3 id="confirmDeleteProxyTitle">
                    <span class="modal-title-text">确认删除</span>
                    <button class="btn-icon-sm" onclick="hideConfirmDeleteProxyModal()" title="取消">
                        <i class="fa fa-times"></i>
                    </button>
                </h3>
                <p id="confirmDeleteProxyMessage"></p>
                <div class="modal-buttons">
                    <button id="confirmDeleteProxyCancelBtn" class="btn btn-cancel">取消</button>
                    <button id="confirmDeleteProxyConfirmBtn" class="btn btn-danger">确认删除</button>
                </div>
            </div>
        </div>
        <div id="confirmClearAllProxiesModal" class="modal-overlay hidden">
            <div class="modal-form-container">
                <h3>
                    <span class="modal-title-text">确认清空所有代理</span>
                    <button class="btn-icon-sm" onclick="hideConfirmClearAllProxiesModal()" title="取消">
                        <i class="fa fa-times"></i>
                    </button>
                </h3>
                <p>这将只保留默认代理</p>
                <div class="modal-buttons">
                    <button id="clearAllProxiesCancelBtn" class="btn btn-cancel">取消</button>
                    <button id="clearAllProxiesConfirmBtn" class="btn btn-danger">确认清空</button>
                </div>
            </div>
        </div>
    </div>

<script>
document.documentElement.style.userSelect = 'none';
// 常量: Toast通知显示时长 (毫秒)
const TOAST_DURATION = 2000;
// 常量: 用于测试代理连通性的URL
const PROXY_TEST_URL = 'https://raw.githubusercontent.com/rjdsq/rjdsq.github.io/main/proxy/proxy.txt';
    
    // 全局状态管理对象
    const state = {
        token: localStorage.getItem('gh_token') || null,
        currentRepo: null,
        currentPath: '',
        currentBranch: null,
        branches: [],
        files: [],
        displayFiles: [],
        repos: [],
        selectedFile: null,
        selectedRepo: null,
        uploadQueue: [],
        editingFile: null,
        fileSha: '',
        originalContent: '',
        proxies: JSON.parse(localStorage.getItem('proxies') || '[{"url": "https://gh-proxy.com/", "latency": null, "status": null, "err": null, "type": null}]'),
        activeProxyIndex: parseInt(localStorage.getItem('active_proxy_index') || '0'),
        proxyGlobalEnable: JSON.parse(localStorage.getItem('proxy_global_enable') || 'true'),
        autoSelectProxy: JSON.parse(localStorage.getItem('proxy_auto_select') || 'false'), // 新增: 自动选择代理, 默认关闭
        editingProxyIndex: null,
        lastTestResult: null,
        lastTestUrl: null,
        user: null,
        fileCache: new Map(),
        viewMode: localStorage.getItem('view_mode') || 'list',
        sortBy: localStorage.getItem('sort_by') || 'name_asc',
        searchQuery: ''
    };
    if (state.proxies.length === 0) {
        state.activeProxyIndex = -1;
    } else if (state.activeProxyIndex < 0 || state.activeProxyIndex >= state.proxies.length) {
        state.activeProxyIndex = 0;
    }
    
    // DOM元素快速访问集合
    const el = {
        authScreen: document.getElementById('authScreen'),
        app: document.getElementById('app'),
        tokenInput: document.getElementById('tokenInput'),
        authBtn: document.getElementById('authBtn'),
        fileList: document.getElementById('fileList'),
        repoList: document.getElementById('repoList'),
        pathNav: document.getElementById('pathNav'),
        pathNavContainer: document.getElementById('pathNavContainer'),
        currentRepo: document.getElementById('currentRepo'),
        branchSwitcherContainer: document.getElementById('branchSwitcherContainer'),
        backBtn: document.getElementById('backBtn'),
        newFolderBtn: document.getElementById('newFolderBtn'),
        uploadBtn: document.getElementById('uploadBtn'),
        modalOverlay: document.getElementById('modalOverlay'),
        modalContent: document.getElementById('modalContent'),
        contextMenu: document.getElementById('contextMenu'),
        contextMenuItems: document.getElementById('contextMenuItems'),
        toast: document.getElementById('toast'),
        toastMessage: document.getElementById('toastMessage'),
        uploadPanel: document.getElementById('uploadPanel'),
        uploadItems: document.getElementById('uploadItems'),
        editModal: document.getElementById('editModal'),
        editFileName: document.getElementById('editFileName'),
        fileContent: document.getElementById('fileContent'),
        closeEditModal: document.getElementById('closeEditModal'),
        cancelEdit: document.getElementById('cancelEdit'),
        saveEdit: document.getElementById('saveEdit'),
        editStatus: document.getElementById('editStatus'),
        editorOverlay: document.getElementById('editorOverlay'),
        saveNotification: document.getElementById('saveNotification'),
        fileUploadInput: document.getElementById('fileUploadInput'),
        mainMenuPopup: document.getElementById('mainMenuPopup'),
        menuLogout: document.getElementById('menuLogout'),
        menuRepoList: document.getElementById('menuRepoList'),
        menuProxySettings: document.getElementById('menuProxySettings'),
        menuClearCache: document.getElementById('menuClearCache'),
        menuRefresh: document.getElementById('menuRefresh'),
        newFileBtn: document.getElementById('newFileBtn'),
        mainMenuBtn: document.getElementById('mainMenuBtn'),
        toolbar: document.getElementById('toolbar'),
        searchInput: document.getElementById('searchInput'),
        sortSelect: document.getElementById('sortSelect'), 
        viewToggleBtn: document.getElementById('viewToggleBtn'),
        proxyQuickToggle: document.getElementById('proxyQuickToggle'),
        proxySettingsModal: document.getElementById('proxySettingsModal'),
        proxyAutoSelectToggle: document.getElementById('proxyAutoSelectToggle'), // 新增: 自动选择代理按钮
        proxyGlobalEnableToggle: document.getElementById('proxyGlobalEnableToggle'),
        proxyAddBtn: document.getElementById('proxyAddBtn'),
        proxyListContainer: document.getElementById('proxyListContainer'),
        proxyListEmpty: document.getElementById('proxyListEmpty'),
        proxyTestAllBtn: document.getElementById('proxyTestAllBtn'),
        proxyTestAllSpinner: document.getElementById('proxyTestAllSpinner'),
        proxyClearAllBtn: document.getElementById('proxyClearAllBtn'),
        proxyCancelSettingsBtn: document.getElementById('proxyCancelSettingsBtn'),
        addEditProxyModal: document.getElementById('addEditProxyModal'),
        addEditProxyTitle: document.getElementById('addEditProxyTitle'),
        addEditProxyUrlInput: document.getElementById('addEditProxyUrlInput'),
        addEditProxyError: document.getElementById('addEditProxyError'),
        autoDetectedProxyType: document.getElementById('autoDetectedProxyType'),
        addEditProxySaveBtn: document.getElementById('addEditProxySaveBtn'),
        confirmDeleteProxyModal: document.getElementById('confirmDeleteProxyModal'),
        confirmDeleteProxyTitle: document.getElementById('confirmDeleteProxyTitle'),
        confirmDeleteProxyMessage: document.getElementById('confirmDeleteProxyMessage'),
        confirmDeleteProxyCancelBtn: document.getElementById('confirmDeleteProxyCancelBtn'),
        confirmDeleteProxyConfirmBtn: document.getElementById('confirmDeleteProxyConfirmBtn'),
        confirmClearAllProxiesModal: document.getElementById('confirmClearAllProxiesModal'),
        clearAllProxiesCancelBtn: document.getElementById('clearAllProxiesCancelBtn'),
        clearAllProxiesConfirmBtn: document.getElementById('clearAllProxiesConfirmBtn'),
        renameModal: document.getElementById('renameModal'),
        renameTitle: document.getElementById('renameTitle'),
        renameInput: document.getElementById('renameInput'),
        renameWarn: document.getElementById('renameWarn'),
        renameCancel: document.getElementById('renameCancel'),
        renameConfirm: document.getElementById('renameConfirm'),
        deleteModal: document.getElementById('deleteModal'),
        deleteTitle: document.getElementById('deleteTitle'),
        deleteDesc: document.getElementById('deleteDesc'),
        deleteCancel: document.getElementById('deleteCancel'),
        deleteConfirm: document.getElementById('deleteConfirm'),
        createRepoModal: document.getElementById('createRepoModal'),
        createRepoNameInput: document.getElementById('createRepoNameInput'),
        createRepoDescInput: document.getElementById('createRepoDescInput'),
        createRepoPrivate: document.getElementById('createRepoPrivate'),
        repoNameError: document.getElementById('repoNameError'),
        createRepoCancel: document.getElementById('createRepoCancel'),
        createRepoConfirm: document.getElementById('createRepoConfirm'),
        createFolderModal: document.getElementById('createFolderModal'),
        createFolderInput: document.getElementById('createFolderInput'),
        createFolderCancel: document.getElementById('createFolderCancel'),
        createFolderConfirm: document.getElementById('createFolderConfirm'),
        createFileModal: document.getElementById('createFileModal'),
        createFileNameInput: document.getElementById('createFileNameInput'),
        createFileContentInput: document.getElementById('createFileContentInput'),
        createFileCancel: document.getElementById('createFileCancel'),
        createFileConfirm: document.getElementById('createFileConfirm'),
        createBranchModal: document.getElementById('createBranchModal'),
        createBranchSource: document.getElementById('createBranchSource'),
        createBranchNameInput: document.getElementById('createBranchNameInput'),
        createBranchCancel: document.getElementById('createBranchCancel'),
        createBranchConfirm: document.getElementById('createBranchConfirm'),
        deleteBranchBtn: document.getElementById('deleteBranchBtn'),
        searchToggleBtn: document.getElementById('searchToggleBtn'),
        sortToggleBtn: document.getElementById('sortToggleBtn'),
        customSortDropdown: document.getElementById('customSortDropdown'),
        userAvatar: document.getElementById('userAvatar'),
        userAvatarPlaceholder: document.getElementById('userAvatarPlaceholder'),
        userName: document.getElementById('userName'),
    };
    
    //  根据文件名获取FontAwesome图标类
    function getFileIcon(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        const icons = {
            js: 'fa-code',
            html: 'fa-html5',
            css: 'fa-css3',
            json: 'fa-file-code-o',
            md: 'fa-file-text-o',
            png: 'fa-file-image-o',
            jpg: 'fa-file-image-o',
            jpeg: 'fa-file-image-o',
            gif: 'fa-file-image-o',
            pdf: 'fa-file-pdf-o',
            zip: 'fa-file-zip-o',
            git: 'fa-git',
            mp3: 'fa-music',
            wav: 'fa-music',
            ogg: 'fa-music',
            flac: 'fa-music',
            m4a: 'fa-music',
            mp4: 'fa-film',
            webm: 'fa-film',
            mov: 'fa-film',
            mkv: 'fa-film',
            avi: 'fa-film'
        };
        return icons[ext] || 'fa-file-o';
    }
    
    //  格式化文件大小 (B, KB, MB...)
    function formatSize(bytes) {
        if (!bytes && bytes !== 0) return '';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.max(0, Math.log(bytes || 1) / Math.log(k)));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    //  格式化相对时间 (例如: 5分钟前)
    function formatRelativeTime(date) {
        const diffMs = new Date() - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMins / 60);
        const diffDays = Math.floor(diffHours / 24);
        if (diffMins < 1) return '刚刚';
        if (diffMins < 60) return `${diffMins}分钟前`;
        if (diffHours < 24) return `${diffHours}小时前`;
        if (diffDays < 30) return `${diffDays}天前`;
        return date.toLocaleDateString();
    }
    
    //  转义HTML特殊字符，防止XSS
    function escapeHtml(unsafe) {
        return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;")
            .replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }
    
    //  从URL中提取域名
    function getDomainFromUrl(url) {
        try {
            const urlObj = new URL(url.startsWith('http') ? url : `https://${url}`);
            return urlObj.hostname;
        } catch (e) {
            return '';
        }
    }
    
    //  根据当前激活的代理，获取代理后的URL
    function getProxiedUrl(originalUrl) {
        if (!state.proxyGlobalEnable || state.proxies.length === 0 || state.activeProxyIndex === -1) {
            return originalUrl;
        }
        const activeProxy = state.proxies[state.activeProxyIndex];
        if (!activeProxy || !activeProxy.url || activeProxy.status === 'fail' || !activeProxy.type) {
            return originalUrl;
        }
        const isRawGitHubUserContent = originalUrl.startsWith('https://raw.githubusercontent.com/');
        if (!isRawGitHubUserContent) {
            return originalUrl;
        }
        let proxiedUrl = originalUrl;
        const proxyInputUrl = (activeProxy.url || '').trim();
        const proxyDomain = getDomainFromUrl(proxyInputUrl);
        if (activeProxy.type === 'prefix') {
            let base = proxyInputUrl;
            if (!base.endsWith('/')) {
                base += '/';
            }
            proxiedUrl = base + originalUrl;
        } else if (activeProxy.type === 'raw_domain_replace') {
            proxiedUrl = originalUrl.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
            if (!proxiedUrl.startsWith('http')) {
                proxiedUrl = 'https://' + proxiedUrl;
            }
        } else {
            proxiedUrl = originalUrl;
        }
        return proxiedUrl;
    }
    
    //  对文件列表进行搜索和排序
    function applyFiltersAndSort() {
        let arr = Array.isArray(state.files) ? [...state.files] : [];
        const q = (state.searchQuery || '').toLowerCase();
        if (q) {
            arr = arr.filter(f => (f.name || '').toLowerCase().includes(q));
        }
        const by = state.sortBy;
        const sorters = {
            name_asc: (a, b) => a.type === b.type ? a.name.localeCompare(b.name) : a.type === 'dir' ? -1 : 1,
            name_desc: (a, b) => a.type === b.type ? b.name.localeCompare(a.name) : a.type === 'dir' ? -1 : 1,
            time_desc: (a, b) => {
                const ta = a.last_modified ? +new Date(a.last_modified) : 0;
                const tb = b.last_modified ? +new Date(b.last_modified) : 0;
                if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
                return tb - ta;
            },
            time_asc: (a, b) => {
                const ta = a.last_modified ? +new Date(a.last_modified) : 0;
                const tb = b.last_modified ? +new Date(b.last_modified) : 0;
                if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
                return ta - tb;
            },
            size_desc: (a, b) => {
                if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
                return (b.size || 0) - (a.size || 0);
            },
            size_asc: (a, b) => {
                if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
                return (a.size || 0) - (b.size || 0);
            }
        };
        (sorters[by] || sorters.name_asc) && arr.sort(sorters[by]);
        state.displayFiles = arr;
    }
    
    //  更新文件列表的视图模式 (列表/网格)
    function updateFileListViewMode() {
        if (!el.fileList) return;
        if (state.viewMode === 'grid') {
            el.fileList.classList.add('grid');
            el.viewToggleBtn && el.viewToggleBtn.classList.add('active');
            if (el.viewToggleBtn) {
                el.viewToggleBtn.title = '切换为列表视图';
                el.viewToggleBtn.innerHTML = '<i class="fa fa-list"></i>';
            }
        } else {
            el.fileList.classList.remove('grid');
            el.viewToggleBtn && el.viewToggleBtn.classList.remove('active');
            if (el.viewToggleBtn) {
                el.viewToggleBtn.title = '切换为网格视图';
                el.viewToggleBtn.innerHTML = '<i class="fa fa-th-large"></i>';
            }
        }
    }
    
    //  更新代理开关按钮的UI状态
    function updateProxyToggleUI() {
        const isEnabled = !!state.proxyGlobalEnable;
        const currentProxy = state.proxies[state.activeProxyIndex];
        const title = isEnabled && currentProxy ? `代理已开启 (${currentProxy.url})` : '代理已关闭';

        [el.proxyQuickToggle, el.proxyGlobalEnableToggle].forEach(toggle => {
            if(toggle) {
                toggle.classList.toggle('active', isEnabled);
                toggle.title = title;
            }
        });
    }
    
    //  更新所有与代理相关的UI
    function updateProxyUI() {
        updateProxyToggleUI();
    }
    
    //  切换仓库列表和文件列表的视图
    function toggleView(showRepoList) {
        if (showRepoList) {
            el.repoList.classList.remove('hidden');
            el.fileList.classList.add('hidden');
            el.toolbar.classList.add('hidden');
            el.pathNavContainer.classList.add('hidden');
            el.branchSwitcherContainer.classList.add('hidden');
            el.currentRepo.textContent = '选择仓库';
            el.newFolderBtn.title = '新建仓库';
            el.newFolderBtn.innerHTML = '<i class="fa fa-plus"></i>';
        } else {
            el.repoList.classList.add('hidden');
            el.fileList.classList.remove('hidden');
            el.toolbar.classList.remove('hidden');
            el.pathNavContainer.classList.remove('hidden');
            el.branchSwitcherContainer.classList.remove('hidden');
            el.newFolderBtn.title = '新建文件夹';
            el.newFolderBtn.innerHTML = '<i class="fa fa-folder"></i>';
            updateFileListViewMode();
        }
    }
    
    //  显示登录授权界面
    function showAuth() {
        el.authScreen.classList.remove('hidden');
        el.app.classList.add('hidden');
    }
    
    //  显示主应用界面
    function showApp() {
        el.authScreen.classList.add('hidden');
        el.app.classList.remove('hidden');
    }
    
    //  显示通用模态框
    function showModal(content) {
        el.modalContent.innerHTML = content;
        el.modalOverlay.classList.remove('hidden');
        el.modalOverlay.classList.add('flex');
    }
    
    //  隐藏通用模态框
    function hideModal() {
        el.modalOverlay.classList.add('hidden');
        el.modalOverlay.classList.remove('flex');
        el.modalContent.innerHTML = '';
    }
    
    //  显示Toast通知
    function showToast(message) {
        el.toastMessage.innerHTML = message.replace(/\n/g, '<br>');
        el.toast.classList.remove('hidden');
        setTimeout(() => el.toast.classList.add('hidden'), 4000);
    }
    
    //  显示文件保存成功的通知
    function showSaveNotification() {
        el.saveNotification.classList.add('show');
        setTimeout(() => el.saveNotification.classList.remove('show'), 3000);
    }
    
    //  从GitHub API获取用户信息
    async function fetchUserInfo() {
        try {
            const res = await fetch('https://api.github.com/user', {
                headers: {
                    Authorization: `token ${state.token}`,
                    'User-Agent': 'Mozilla/5.0'
                }
            });
            if (res.ok) {
                state.user = await res.json();
                updateUserUI();
            }
        } catch (e) {
            console.error("Failed to fetch user info", e);
        }
    }
    
    //  更新用户信息的UI (头像和名称)
    function updateUserUI() {
        if (state.user) {
            el.userName.textContent = state.user.login;
            el.userAvatar.src = state.user.avatar_url;
            el.userAvatar.classList.remove('hidden');
            el.userAvatarPlaceholder.classList.add('hidden');
        }
    }
    
    //  从缓存加载仓库列表
    function loadReposFromCache() {
        const cachedRepos = localStorage.getItem('cached_repos');
        const cacheTime = localStorage.getItem('repos_cache_time');
        if (cachedRepos && cacheTime) {
            try {
                state.repos = JSON.parse(cachedRepos);
                renderRepoList();
                showRepoListView();
                // 在后台静默更新仓库列表缓存
                /*
                setTimeout(() => {
                    fetchReposInBackground();
                }, 1000);
                */
                return;
            } catch (e) {
                console.error('缓存数据解析失败:', e);
            }
        }
        fetchRepos();
    }
    
    //  在后台获取最新的仓库列表并更新缓存
    async function fetchReposInBackground() {
        try {
            const res = await fetch('https://api.github.com/user/repos?timestamp=' + Date.now(), {
                headers: {
                    Authorization: `token ${state.token}`,
                    'User-Agent': 'Mozilla/5.0'
                }
            });
            if (res.ok) {
                const repos = await res.json();
                localStorage.setItem('cached_repos', JSON.stringify(repos));
                localStorage.setItem('repos_cache_time', Date.now().toString());
            }
        } catch (err) {
            console.log('后台更新失败:', err);
        }
    }
    
    //  从GitHub API获取仓库列表
    async function fetchRepos() {
        try {
            state.repos = [];
            el.repoList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
            const res = await fetch('https://api.github.com/user/repos?timestamp=' + Date.now(), {
                headers: {
                    Authorization: `token ${state.token}`,
                    'User-Agent': 'Mozilla/5.0'
                }
            });
            if (!res.ok) throw new Error('获取仓库失败');
            state.repos = await res.json();
            localStorage.setItem('cached_repos', JSON.stringify(state.repos));
            localStorage.setItem('repos_cache_time', Date.now().toString());
            renderRepoList();
            showRepoListView();
        } catch (err) {
            showToast('加载仓库失败');
            console.error(err);
        }
    }
    
    //  渲染仓库列表到页面
    function renderRepoList() {
    state.repos.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
    el.repoList.innerHTML = state.repos.length === 0 ? '<div class="empty-state"><i class="fa fa-github"></i><p>没有找到仓库</p></div>' : '';
    state.repos.forEach(repo => {
        const item = document.createElement('div');
        item.className = 'file-item';
        item.innerHTML = `
                <div class="file-icon"><i class="fa fa-github"></i></div>
                <div class="file-info">
                    <p class="file-name">${repo.name}</p>
                    <p class="file-meta">
                        ${repo.private ? '私有仓库' : '公开仓库'} ${repo.size || repo.updated_at ? ' · ' : ''}
                        ${repo.size ? formatSize(repo.size * 1024) : ''}
                        ${repo.size && repo.updated_at ? ' · ' : ''}
                        ${formatRelativeTime(new Date(repo.updated_at))}
                    </p>
                    <p class="file-meta">${repo.description || ''}</p>
                </div>
            `;

        item.addEventListener('click', async () => {
            const lastBranch = localStorage.getItem(`last_branch_${repo.full_name}`);
            const branchToLoad = lastBranch || repo.default_branch;

            const newState = {
                repo: repo.full_name,
                path: '',
                branch: branchToLoad
            };
            history.pushState(newState, '', `#/${repo.full_name}`);
            state.currentRepo = repo.full_name;
            state.currentPath = '';
            state.currentBranch = branchToLoad;
            el.currentRepo.textContent = repo.name;

            renderPathNav();
            toggleView(false);

            await fetchBranches(repo);
            renderBranchSwitcher();
            fetchFiles();
        });
        let pressTimer = null;
        item.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                pressTimer = setTimeout(() => {
                    e.preventDefault();
                    state.selectedRepo = repo;
                    showRepoContextMenu(e, repo);
                    pressTimer = null;
                }, 500);
            }
        }, {
            passive: false
        });
        item.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                pressTimer = setTimeout(() => {
                    e.preventDefault();
                    state.selectedRepo = repo;
                    showRepoContextMenu(e, repo);
                    pressTimer = null;
                }, 500);
            }
        });
        ['touchend', 'touchcancel', 'mouseup', 'mouseleave'].forEach(event => {
            item.addEventListener(event, () => {
                if (pressTimer) {
                    clearTimeout(pressTimer);
                    pressTimer = null;
                }
            });
        });
        item.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (pressTimer) {
                clearTimeout(pressTimer);
                pressTimer = null;
            }
            state.selectedRepo = repo;
            showRepoContextMenu(e, repo);
        });
        el.repoList.appendChild(item);
    });
}
    
    //  显示仓库列表视图
    function showRepoListView() {
        el.repoList.classList.remove('hidden');
        el.fileList.classList.add('hidden');
        el.pathNavContainer.classList.add('hidden');
        el.branchSwitcherContainer.classList.add('hidden');
        el.currentRepo.textContent = '选择仓库';
        toggleView(true);
        state.currentRepo = null;
        state.currentPath = '';
        state.currentBranch = null;
        state.branches = [];
    }
    
    //  获取仓库的分支列表
    async function fetchBranches(repo) {
        try {
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}/branches`, {
                headers: {
                    Authorization: `token ${state.token}`,
                    'User-Agent': 'Mozilla/5.0'
                }
            });
            if (res.ok) {
                state.branches = await res.json();
            } else {
                state.branches = [];
                showToast('获取分支列表失败');
            }
        } catch (e) {
            state.branches = [];
            showToast('获取分支列表失败');
            console.error(e);
        }
    }
    
    //  渲染分支切换的下拉框
    // 找到旧的 renderBranchSwitcher 函数，然后用这个新版本替换它

// 请用这个【修正版】的函数，完整替换掉旧的 renderBranchSwitcher 函数

function renderBranchSwitcher() {
    const container = el.branchSwitcherContainer;
    container.innerHTML = ''; // 清空容器

    if (state.branches.length === 0) {
        container.classList.add('hidden');
        return;
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'custom-branch-select-wrapper';

    const trigger = document.createElement('button');
    trigger.className = 'custom-branch-select-trigger';
    trigger.innerHTML = `
        <span>${state.currentBranch}</span>
        <i class="fa fa-chevron-down"></i>
    `;
    
    const optionsPanel = document.createElement('div');
    optionsPanel.className = 'custom-branch-select-options';

    state.branches.forEach(branch => {
        const option = document.createElement('div');
        option.className = 'custom-branch-select-option';
        if (branch.name === state.currentBranch) {
            option.classList.add('selected');
        }
        option.textContent = branch.name;
        option.dataset.branchName = branch.name;

        option.addEventListener('click', () => {
            const selectedBranch = option.dataset.branchName;
            
            if (selectedBranch === state.currentBranch) {
                wrapper.classList.remove('open');
                return;
            }

            // --- START: BUG修复代码 ---
            // 1. 找到之前被选中的旧选项，并移除它的高亮样式
            const previouslySelected = optionsPanel.querySelector('.custom-branch-select-option.selected');
            if (previouslySelected) {
                previouslySelected.classList.remove('selected');
            }

            // 2. 给刚刚被点击的新选项，添加上高亮样式
            option.classList.add('selected');
            // --- END: BUG修复代码 ---

            // 更新状态
            state.currentBranch = selectedBranch;
            state.currentPath = '';
            localStorage.setItem(`last_branch_${state.currentRepo}`, state.currentBranch);

            // 加载新分支的文件
            el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
            const newState = { repo: state.currentRepo, path: '', branch: state.currentBranch };
            history.replaceState(newState, '', `#/${state.currentRepo}/`);
            renderPathNav();
            fetchFiles(true);

            // 更新触发器显示的文本
            trigger.querySelector('span').textContent = selectedBranch;
            
            // 收起菜单
            wrapper.classList.remove('open');
        });

        optionsPanel.appendChild(option);
    });

    wrapper.appendChild(trigger);
    wrapper.appendChild(optionsPanel);
    container.appendChild(wrapper);
    container.classList.remove('hidden');

    trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        wrapper.classList.toggle('open');
    });

    document.addEventListener('click', (e) => {
        if (!wrapper.contains(e.target)) {
            wrapper.classList.remove('open');
        }
    });
}
    
    //  获取文件列表 (会优先使用缓存)
    async function fetchFiles(forceRefresh = false) {
        if (!state.currentRepo || !state.currentBranch) return;
        const cacheKey = `${state.currentRepo}:${state.currentBranch}:${state.currentPath}`;
        if (!forceRefresh && state.fileCache.has(cacheKey)) {
            state.files = state.fileCache.get(cacheKey);
            applyFiltersAndSort();
            renderFileList();
            // 在后台静默更新文件列表缓存
            /*
            setTimeout(() => {
                fetchFilesInBackground(cacheKey);
            }, 2000);
            */
            return;
        }
        await fetchFilesFromNetwork(cacheKey);
    }
    
    //  从网络获取文件列表
    async function fetchFilesFromNetwork(cacheKey) {
        el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
        try {
            const timestamp = Date.now();
            const url = `https://api.github.com/repos/${state.currentRepo}/contents/${state.currentPath}?ref=${state.currentBranch}&t=${timestamp}`;
            const res = await fetch(url, {
                headers: {
                    Authorization: `token ${state.token}`,
                    'User-Agent': 'Mozilla/5.0'
                },
                cache: 'no-store'
            });
            if (!res.ok) {
                if (res.status === 404) {
                    state.files = [];
                    applyFiltersAndSort();
                    renderFileList();
                    return;
                }
                throw new Error('加载文件失败');
            }
            const data = await res.json();
            if (data.message) throw new Error(data.message);
            state.files = Array.isArray(data) ? data : [];
            state.files.sort((a, b) => a.type === 'dir' && b.type !== 'dir' ? -1 : a.type !== 'dir' && b.type === 'dir' ? 1 : a.name.localeCompare(b.name));
            state.fileCache.set(cacheKey, [...state.files]);
            await Promise.all(state.files.map(async (file) => {
                try {
                    const [owner, repo] = state.currentRepo.split('/');
                    const commitsUrl = `https://api.github.com/repos/${owner}/${repo}/commits?path=${file.path}&sha=${state.currentBranch}&per_page=1`;
                    const r = await fetch(commitsUrl, {
                        headers: {
                            Authorization: `token ${state.token}`,
                            'User-Agent': 'Mozilla/5.0'
                        }
                    });
                    const commits = await r.json();
                    if (Array.isArray(commits) && commits.length > 0) {
                        file.last_modified = commits[0].commit.committer.date;
                    }
                } catch (e) {
                    file.last_modified = null;
                }
            }));
            state.fileCache.set(cacheKey, [...state.files]);
            applyFiltersAndSort();
            renderFileList();
        } catch (err) {
            if (err.message.includes('404')) {
                state.files = [];
                applyFiltersAndSort();
                renderFileList();
                return;
            }
            showToast('加载文件失败: ' + err.message);
            console.error(err);
        }
    }
    
    //  在后台获取文件列表并更新缓存
    async function fetchFilesInBackground(cacheKey) {
        try {
            const timestamp = Date.now();
            const url = `https://api.github.com/repos/${state.currentRepo}/contents/${state.currentPath}?ref=${state.currentBranch}&t=${timestamp}`;
            const res = await fetch(url, {
                headers: {
                    Authorization: `token ${state.token}`,
                    'User-Agent': 'Mozilla/5.0'
                },
                cache: 'no-store'
            });
            if (res.ok) {
                const data = await res.json();
                if (!data.message && Array.isArray(data)) {
                    const files = data.sort((a, b) => a.type === 'dir' && b.type !== 'dir' ? -1 : a.type !== 'dir' && b.type === 'dir' ? 1 : a.name.localeCompare(b.name));
                    state.fileCache.set(cacheKey, [...files]);
                }
            }
        } catch (err) {
            console.log('后台文件更新失败:', err);
        }
    }
    
    //  渲染文件列表到页面
    function renderFileList() {
    const list = (state.displayFiles && state.displayFiles.length >= 0) ? state.displayFiles : state.files;
    el.fileList.innerHTML = (!list || list.length === 0) ? '<div class="empty-state"><i class="fa fa-github"></i><p>此分支为空</p></div>' : '';
    const imageExtensions = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'];
    (list || []).forEach((file) => {
        const isDir = file.type === 'dir';
        const icon = isDir ? 'fa-folder' : getFileIcon(file.name);
        const item = document.createElement('div');
        item.className = 'file-item';
        const fileExtension = file.name.split('.').pop()?.toLowerCase();
        const isImage = !isDir && imageExtensions.includes(fileExtension);

        item.className = isImage ? 'file-item is-image-grid' : 'file-item';

        let iconOrThumbnailHtml = '';
        if (isImage) {
            const rawUrl = (file.download_url) ? file.download_url : file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
            const imageUrl = getProxiedUrl(rawUrl);
            iconOrThumbnailHtml = `<img src="${imageUrl}" class="file-thumbnail" alt="${file.name}">`;
        } else {
            iconOrThumbnailHtml = `<div class="file-icon"><i class="fa ${icon}"></i></div>`;
        }
        item.innerHTML = `
                ${iconOrThumbnailHtml}
                <div class="file-info">
                    <p class="file-name">${file.name}</p>
                    <p class="file-meta">
                        ${isDir ? '文件夹' : formatSize(file.size)} · ${file.last_modified ? formatRelativeTime(new Date(file.last_modified)) : '加载中'}
                    </p>
                </div>
            `;
        let pressTimer = null;
        item.addEventListener('click', (e) => {
            if (pressTimer) clearTimeout(pressTimer);
            if (e.imagePreviewAction) return;
            isDir ? navigateToDir(file.name) : editFile(file);
        });
        item.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                pressTimer = setTimeout(() => {
                    e.preventDefault();
                    showContextMenu(e, file);
                    pressTimer = null;
                }, 700);
            }
        }, {
            passive: false
        });
        item.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                pressTimer = setTimeout(() => {
                    e.preventDefault();
                    showContextMenu(e, file);
                    pressTimer = null;
                }, 700);
            }
        });
        ['touchend', 'touchcancel', 'mouseup', 'mouseleave'].forEach(event => {
            item.addEventListener(event, () => {
                if (pressTimer) {
                    clearTimeout(pressTimer);
                    pressTimer = null;
                }
            });
        });
        item.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (pressTimer) {
                clearTimeout(pressTimer);
                pressTimer = null;
            }
            showContextMenu(e, file);
        });
        el.fileList.appendChild(item);
    });
}
    
    //  渲染面包屑路径导航
    function renderPathNav() {
        el.pathNav.innerHTML = '';
        const parts = state.currentPath.split('/').filter(p => p);
        let currentPath = '';
        addPathItem('', '/');
        parts.forEach((part) => {
            currentPath += part + '/';
            addPathItem(part, currentPath);
        });
    }
    
    //  向面包屑导航添加一个路径项
    function addPathItem(name, path) {
        const item = document.createElement('span');
        item.className = 'path-item';
        item.textContent = name;
        item.dataset.path = path;
        item.addEventListener('click', () => {
            el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
            navigateToPath(path);
        });
        el.pathNav.appendChild(item);
        if (name !== '/') el.pathNav.appendChild(document.createTextNode(' / '));
    }
    
    //  导航到子目录
    function navigateToDir(dirName) {
        const newPath = state.currentPath ? `${state.currentPath}${dirName}/` : `${dirName}/`;
        navigateToPath(newPath);
    }
    
    //  导航到指定路径
    function navigateToPath(path) {
    state.currentPath = path;
    renderPathNav();
    el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';

    const newState = {
        repo: state.currentRepo,
        path: path,
        branch: state.currentBranch
    };
    history.pushState(newState, '', `#/${state.currentRepo}/${path}`);

    fetchFiles();
}
    
    //  设置所有DOM元素的事件监听器
    function setupEventListeners() {
        el.newFolderBtn.onclick = function() {
            if (!state.currentRepo) {
                showCreateRepoModal();
            } else {
                showCreateFolderModal();
            }
        };
        el.authBtn.addEventListener('click', async () => {
            const token = el.tokenInput.value.trim();
            if (token) {
                localStorage.setItem('gh_token', token);
                state.token = token;
                showApp();
                await Promise.all([fetchRepos(), fetchUserInfo()]);
                // 登录后, 根据用户设置决定是否自动优选代理
                if (state.autoSelectProxy) {
                    findAndSetBestProxy();
                } else {
                    updateProxyUI();
                }
            } else {
                showToast('请输入令牌');
            }
        });
        el.mainMenuBtn.onclick = (e) => {
            e.stopPropagation();
            hideContextMenu();
            el.mainMenuPopup.classList.toggle('hidden');
        };
        document.addEventListener('click', function(e) {
            if (!el.mainMenuPopup.classList.contains('hidden')) {
                if (!el.mainMenuPopup.contains(e.target) && e.target !== el.mainMenuBtn) {
                    el.mainMenuPopup.classList.add('hidden');
                }
            }
            if (!el.customSortDropdown.classList.contains('hidden') && !el.customSortDropdown.contains(e.target) && e.target !== el.sortToggleBtn) {
                el.customSortDropdown.classList.add('hidden');
            }
        });
        el.menuRepoList.onclick = () => {
            el.mainMenuPopup.classList.add('hidden');
            showRepoListView();
        };
        el.menuRefresh.onclick = () => {
            el.mainMenuPopup.classList.add('hidden');
            if (!state.currentRepo) {
                fetchRepos();
            } else {
                fetchFiles(true);
            }
        };
        el.menuLogout.onclick = () => {
            el.mainMenuPopup.classList.add('hidden');
            localStorage.removeItem('gh_token');
            state.token = null;
            state.repos = [];
            state.currentRepo = null;
            state.user = null;
            showAuth();
        };

        const toggleProxyAndRefresh = async () => {
            state.proxyGlobalEnable = !state.proxyGlobalEnable;
            localStorage.setItem('proxy_global_enable', JSON.stringify(state.proxyGlobalEnable));
            updateProxyUI();
            showToast(state.proxyGlobalEnable ? '代理已开启' : '代理已关闭');
            if (state.currentRepo && !el.fileList.classList.contains('hidden')) {
                el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
                await fetchFiles(true);
            }
        };

        el.proxyGlobalEnableToggle.addEventListener('click', toggleProxyAndRefresh);
        el.proxyQuickToggle.addEventListener('click', toggleProxyAndRefresh);

        el.menuProxySettings.addEventListener('click', () => {
            el.mainMenuPopup.classList.add('hidden');
            openProxySettingsModal();
        });
        el.menuClearCache.addEventListener('click', clearCache);
        el.saveEdit.addEventListener('click', saveEditedFile);
        el.closeEditModal.onclick = hideEditModal;
        el.cancelEdit.onclick = hideEditModal;
        document.addEventListener('click', hideContextMenu);
        document.addEventListener('touchstart', (e) => {
            if (!el.contextMenu.contains(e.target)) hideContextMenu();
        });
        document.addEventListener('touchmove', (e) => {
            if (!el.contextMenu.contains(e.target)) hideContextMenu();
        });
        el.modalOverlay.addEventListener('click', (e) => {
            if (e.target === el.modalOverlay) hideModal();
        });
        el.backBtn.onclick = goUp;
        el.newFileBtn.onclick = showCreateFileModal;
        el.uploadBtn.onclick = handleUploadClick;
        el.fileUploadInput.addEventListener('change', handleFilesSelected);
        el.searchToggleBtn.addEventListener('click', () => {
            el.searchInput.classList.toggle('hidden');
            if (!el.searchInput.classList.contains('hidden')) {
                el.searchInput.focus();
                el.searchInput.style.display = 'block';
            } else {
                el.searchInput.value = '';
                state.searchQuery = '';
                applyFiltersAndSort();
                renderFileList();
                el.searchInput.style.display = 'none';
            }
        });
        if (el.searchInput) {
            el.searchInput.addEventListener('input', () => {
                state.searchQuery = el.searchInput.value || '';
                applyFiltersAndSort();
                renderFileList();
            });
        }
        el.sortToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            el.customSortDropdown.classList.toggle('hidden');
        });
        el.customSortDropdown.addEventListener('click', (e) => {
            if (e.target.classList.contains('dropdown-item')) {
                state.sortBy = e.target.dataset.value;
                localStorage.setItem('sort_by', state.sortBy);
                applyFiltersAndSort();
                renderFileList();
                el.customSortDropdown.classList.add('hidden');
                Array.from(el.customSortDropdown.children).forEach(item => {
                    item.classList.remove('selected');
                });
                e.target.classList.add('selected');
            }
        });
        if (el.customSortDropdown) {
            Array.from(el.customSortDropdown.children).forEach(item => {
                if (item.dataset.value === state.sortBy) {
                    item.classList.add('selected');
                }
            });
        }
        if (el.viewToggleBtn) {
            updateFileListViewMode();
            el.viewToggleBtn.addEventListener('click', () => {
                state.viewMode = state.viewMode === 'list' ? 'grid' : 'list';
                localStorage.setItem('view_mode', state.viewMode);
                updateFileListViewMode();
            });
        }
        el.proxyCancelSettingsBtn.addEventListener('click', closeProxySettingsModal);
        
      // “自动优选代理”开关的点击事件
el.proxyAutoSelectToggle.addEventListener('click', () => {
    // 切换状态并保存
    state.autoSelectProxy = !state.autoSelectProxy;
    localStorage.setItem('proxy_auto_select', JSON.stringify(state.autoSelectProxy));
    updateProxySettingsUI(); // 更新按钮的亮/灭状态

    // 根据切换后的状态显示不同的提示信息
    if (state.autoSelectProxy) {
        // 当开启时，只提示，不执行任何操作
        showToast('已开启自动选择最优代理，下次网页加载后生效');
    } else {
        // 当关闭时，也只提示
        showToast('已关闭自动优选代理');
    }
});
        
        el.proxyAddBtn.addEventListener('click', () => openAddEditProxyModal());
        el.proxyTestAllBtn.addEventListener('click', testAllProxies);
        el.proxyClearAllBtn.addEventListener('click', showConfirmClearAllProxiesModal);
        el.addEditProxyUrlInput.addEventListener('input', validateAddEditProxyInput);
        el.addEditProxySaveBtn.addEventListener('click', async () => {
            let url = el.addEditProxyUrlInput.value.trim();
            if (url && !/^https?:\/\//i.test(url)) {
                url = 'https://' + url;
            }

            if (!validateAddEditProxyInput()) {
                return;
            }
            
            el.addEditProxySaveBtn.disabled = true;
            el.addEditProxySaveBtn.classList.add('btn-processing');
            el.addEditProxySaveBtn.innerHTML = `测试中 <span class="spinner-small"></span>`;
            el.addEditProxyError.style.display = 'none';

            const result = await determineBestProxyTypeAndTest(url);
            const proxyObj = state.editingProxyIndex !== null ?
                state.proxies[state.editingProxyIndex] :
                {};

            proxyObj.url = url;
            proxyObj.latency = result.ms;
            proxyObj.status = result.ok ? 'ok' : 'fail';
            proxyObj.err = result.err;
            proxyObj.type = result.type;

            if (state.editingProxyIndex === null) {
                state.proxies.push(proxyObj);
                if (state.proxies.length === 1) {
                    state.activeProxyIndex = 0;
                }
            }
            
            showToast('代理已保存');
            renderProxyList();
            saveProxyConfig();
            closeAddEditProxyModal();
        });
        el.confirmDeleteProxyCancelBtn.addEventListener('click', hideConfirmDeleteProxyModal);
        el.clearAllProxiesCancelBtn.addEventListener('click', hideConfirmClearAllProxiesModal);
        el.clearAllProxiesConfirmBtn.addEventListener('click', clearAllProxiesConfirmed);
        el.renameInput.oninput = function() {
            el.renameConfirm.disabled = !el.renameInput.value.trim() || el.renameInput.value.trim() === state.selectedFile?.name;
        };
        el.renameCancel.onclick = function() {
            el.renameModal.classList.add('hidden');
        };
        el.deleteCancel.onclick = function() {
            el.deleteModal.classList.add('hidden');
        };
        el.createRepoCancel.onclick = function() {
            el.createRepoModal.classList.add('hidden');
        };
        el.createFolderInput.oninput = function() {
            el.createFolderConfirm.disabled = !el.createFolderInput.value.trim();
        };
        el.createFolderCancel.onclick = function() {
            el.createFolderModal.classList.add('hidden');
        };
        el.createFileNameInput.oninput = function() {
            el.createFileConfirm.disabled = !el.createFileNameInput.value.trim() || el.createFileNameInput.value.trim().endsWith('/');
        };
        el.createFileCancel.onclick = function() {
            el.createFileModal.classList.add('hidden');
        };
        el.createBranchNameInput.oninput = function() {
            el.createBranchConfirm.disabled = !el.createBranchNameInput.value.trim();
        }
        el.createBranchCancel.onclick = function() {
            el.createBranchModal.classList.add('hidden');
        };
    }
    
    //  显示文件编辑模态框
    function showEditModal() {
        el.editModal.classList.remove('hidden');
        el.editModal.classList.add('flex');
        el.editorOverlay.classList.add('show');
        setTimeout(adjustEditorDimensions, 10);
    }
    
    //  隐藏文件编辑模态框
    function hideEditModal() {
        el.editModal.classList.add('hidden');
        el.editModal.classList.remove('flex');
        state.editingFile = state.fileSha = state.originalContent = '';
        el.saveEdit.classList.remove('modified');
    }
    
    //  显示编辑器状态信息
    function showEditStatus(text, type) {
        el.editStatus.textContent = text;
        el.editStatus.className = `edit-status ${type}`;
    }
    
    //  调整编辑器尺寸以适应屏幕
    function adjustEditorDimensions() {
        const viewportHeight = window.innerHeight;
        const targetEditorHeight = viewportHeight * 0.6;
        const modal = el.editModal.querySelector('.modal-content');
        const headerHeight = modal.querySelector('.modal-header').offsetHeight;
        const statusHeight = el.editStatus.offsetHeight;
        const footerHeight = modal.querySelector('.modal-footer').offsetHeight;
        const paddingOffset = 20;
        const otherElementsHeight = headerHeight + statusHeight + footerHeight + paddingOffset;
        
        modal.style.height = `${targetEditorHeight + otherElementsHeight}px`;
        el.fileContent.style.height = `${targetEditorHeight}px`;
    }
    
    //  编辑文件
    async function editFile(file) {
        state.editingFile = file;
        el.editFileName.textContent = `${file.name}`;
        el.fileContent.value = '';
        showEditStatus('', '');
        showEditModal();
        try {
            const [owner, repo] = state.currentRepo.split('/');
            const url = `https://api.github.com/repos/${owner}/${repo}/contents/${file.path}?ref=${state.currentBranch}`;
            const res = await fetch(url, {
                headers: {
                    'Authorization': `token ${state.token}`,
                    'User-Agent': 'Mozilla/5.0'
                }
            });
            if (!res.ok) {
                const err = await res.json();
                el.editorOverlay.classList.remove('show');
                showEditStatus(`加载失败：${err.message}`, 'error');
                return;
            }
            const data = await res.json();
            const content = decodeURIComponent(escape(atob(data.content)));
            el.fileContent.value = content;
            state.originalContent = content;
            state.fileSha = data.sha;
            el.editorOverlay.classList.remove('show');
            el.fileContent.oninput = checkContentChanges;
            checkContentChanges();
        } catch (e) {
            el.editorOverlay.classList.remove('show');
            showEditStatus(`错误：${e.message}`, 'error');
            console.error(e);
        }
    }
    
    //  检查文件内容是否有修改
    function checkContentChanges() {
        const isModified = el.fileContent.value !== state.originalContent;
        el.saveEdit.classList.toggle('modified', isModified);
    }
    
    //  保存编辑后的文件
    async function saveEditedFile() {
        if (!state.editingFile || !state.fileSha) return;
        const currentContent = el.fileContent.value;
        if (currentContent === state.originalContent) {
            showToast('未检测到修改');
            return;
        }
        el.editorOverlay.classList.add('show');
        el.saveEdit.classList.add('btn-processing');
        try {
            const [owner, repo] = state.currentRepo.split('/');
            const encodedContent = btoa(unescape(encodeURIComponent(currentContent)));
            const url = `https://api.github.com/repos/${owner}/${repo}/contents/${state.editingFile.path}`;
            const res = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Authorization': `token ${state.token}`,
                    'Content-Type': 'application/json',
                    'User-Agent': 'Mozilla/5.0'
                },
                body: JSON.stringify({
                    message: `Update ${state.editingFile.name} via web editor`,
                    content: encodedContent,
                    sha: state.fileSha,
                    branch: state.currentBranch
                })
            });
            // 以 saveEditedFile 函数为例
if (!res.ok) {
    const err = await res.json();
    // ↓↓↓ 增加精细判断
    if (res.status === 409) {
        showEditStatus(`保存失败：文件已被他人修改，请刷新页面后重试。`, 'error');
    } else {
        showEditStatus(`保存失败：${err.message}`, 'error');
    }
    return;
}
            const result = await res.json();
            state.fileSha = result.content.sha;
            state.originalContent = currentContent;
            el.editorOverlay.classList.remove('show');
            showToast('文件已保存');
            showSaveNotification();
            fetchFiles(true);
            checkContentChanges();
        } catch (e) {
            el.editorOverlay.classList.remove('show');
            showEditStatus(`错误：${e.message}`, 'error');
            console.error(e);
        } finally {
            el.saveEdit.classList.remove('btn-processing');
        }
    }
    
    //  下载文件
    async function downloadFile(item) {
        if (item.type === 'dir') return;
        try {
            showToast(`准备下载 ${item.name}`);
            const rawUrl = (item.download_url) ? item.download_url : item.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
            const url = getProxiedUrl(rawUrl);
            const response = await fetch(url);
            if (!response.ok) throw new Error(`下载失败 (${response.status})`);
            const blob = await response.blob();
            const objectUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = objectUrl;
            a.download = item.name;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(objectUrl);
            }, 500);
            showToast(`开始下载 ${item.name}`);
        } catch (e) {
            showToast(`下载出错: ${e.message}`);
            console.error(e);
        }
    }
    
    //  复制文件的原始(raw)链接
    function copyLink(file) {
        const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        navigator.clipboard.writeText(rawUrl).then(() => {
            showToast('Raw 链接已复制');
        }).catch(e => {
            showToast(`复制失败: ${e.message || '请检查浏览器权限或非安全上下文'}`);
            console.error(e);
        });
    }

    //  复制文件的代理链接
    function copyProxyLink(file) {
        const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');

        let bestAvailableProxy = null;
        state.proxies.forEach(proxy => {
            if (proxy.status === 'ok') {
                if (!bestAvailableProxy || proxy.latency < bestAvailableProxy.latency) {
                    bestAvailableProxy = proxy;
                }
            }
        });

        if (bestAvailableProxy && bestAvailableProxy.url) {
            let proxiedUrl = rawUrl;
            const proxyDomain = getDomainFromUrl(bestAvailableProxy.url);

            if (bestAvailableProxy.type === 'prefix') {
                let base = bestAvailableProxy.url;
                if (!base.endsWith('/')) base += '/';
                proxiedUrl = base + rawUrl;
            } else if (bestAvailableProxy.type === 'raw_domain_replace') {
                proxiedUrl = rawUrl.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
                if (!proxiedUrl.startsWith('http')) proxiedUrl = 'https://' + proxiedUrl;
            }
            
            navigator.clipboard.writeText(proxiedUrl).then(() => {
                const displayUrl = bestAvailableProxy.url.replace(/^https?:\/\//, '').replace(/\/$/, '');
                showToast(`已复制最佳代理链接 [${displayUrl}]`);
            }).catch(e => {
                showToast(`复制失败: ${e.message || '请检查浏览器权限'}`);
                console.error(e);
            });

        } else {
            navigator.clipboard.writeText(rawUrl).then(() => {
                showToast('无可用代理，已复制直连 Raw 链接');
            }).catch(e => {
                showToast(`复制失败: ${e.message || '请检查浏览器权限'}`);
                console.error(e);
            });
        }
    }

    //  计算并定位右键菜单的位置
    function positionContextMenu(e, menuWidth, menuHeight) {
        let clickX, clickY;

        if (e.touches && e.touches.length > 0) {
            clickX = e.touches[0].clientX;
            clickY = e.touches[0].clientY;
        } else {
            clickX = e.clientX;
            clickY = e.clientY;
        }

        const offsetX = 30;
        const offsetY = 30;

        let leftPos = clickX + offsetX;
        let topPos = clickY + offsetY;

        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        if (leftPos + menuWidth > windowWidth) {
            leftPos = clickX - menuWidth - offsetX;
        }

        if (topPos + menuHeight > windowHeight) {
            topPos = clickY - menuHeight - offsetY;
        }
        
        if (leftPos < 0) leftPos = 5;
        if (topPos < 0) topPos = 5;

        return { top: topPos, left: leftPos };
    }

    //  显示文件的右键菜单
    function showContextMenu(e, file) {
        state.selectedFile = file;
        const menu = el.contextMenu;

        menu.style.opacity = '0';
        menu.style.transform = 'scale(0.8)';
        menu.classList.remove('hidden');

        renderContextMenuItems(file);

        const menuWidth = menu.offsetWidth;
        const menuHeight = menu.offsetHeight;

        const position = positionContextMenu(e, menuWidth, menuHeight);
        
        menu.style.top = `${position.top}px`;
        menu.style.left = `${position.left}px`;

        let start = null, duration = 150;
        function animate(timestamp) {
            if (!start) start = timestamp;
            const progress = Math.min((timestamp - start) / duration, 1);
            menu.style.opacity = progress.toString();
            menu.style.transform = `scale(${0.8 + 0.2 * progress})`;
            if (progress < 1) requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
    }
    
    //  显示仓库的右键菜单
    function showRepoContextMenu(e, repo) {
        state.selectedRepo = repo;
        const menu = el.contextMenu;

        menu.style.opacity = '0';
        menu.style.transform = 'scale(0.8)';
        menu.classList.remove('hidden');

        renderRepoContextMenuItems(repo);

        const menuWidth = menu.offsetWidth;
        const menuHeight = menu.offsetHeight;

        const position = positionContextMenu(e, menuWidth, menuHeight);

        menu.style.top = `${position.top}px`;
        menu.style.left = `${position.left}px`;
    let start = null, duration = 150;
        function animate(timestamp) {
            if (!start) start = timestamp;
            const progress = Math.min((timestamp - start) / duration, 1);
            menu.style.opacity = progress.toString();
            menu.style.transform = `scale(${0.8 + 0.2 * progress})`;
            if (progress < 1) requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
    }
    
    //  渲染仓库的右键菜单项
    function renderRepoContextMenuItems(repo) {
        el.contextMenuItems.innerHTML = '';
        [
            ['copyRepoGitHubLink', 'fa-external-link', '复制链接'],
            ['createBranch', 'fa-code-fork', '新建分支'],
            ['downloadRepoDirect', 'fa-download', '下载ZIP'],
            ['renameRepo', 'fa-pencil', '重命名'],
            ['deleteRepo', 'fa-trash', '删除', 'text-red-400']
        ].forEach(([action, icon, text, className = '']) => {
            const item = document.createElement('a');
            item.className = `context-menu-item ${className}`;
            item.dataset.action = action;
            item.innerHTML = `<i class="fa ${icon} mr-2"></i>${text}`;
            item.addEventListener('click', () => {
                handleRepoContextMenuAction(action, state.selectedRepo);
                hideContextMenu();
            });
            el.contextMenuItems.appendChild(item);
        });
    }
    
    //  渲染文件的右键菜单项
    function renderContextMenuItems(file) {
        el.contextMenuItems.innerHTML = '';
        const isDir = file.type === 'dir';
        const items = isDir ? [
        ['copyGitHubLink', 'fa-external-link', '复制链接'],
            ['rename', 'fa-pencil', '重命名'],
            ['delete', 'fa-trash', '删除', 'text-red-400']
        ] : [
            ['edit', 'fa-edit', '编辑文件'],
            ['rename', 'fa-pencil', '重命名'],
            ['download', 'fa-download', '下载文件'],
            ['copyGitHubLink', 'fa-external-link', '复制链接'],
            ['copyLink', 'fa-link', '复制raw链接'],
            ['copyProxy', 'fa-share', '复制代理链接'],  
            ['delete', 'fa-trash', '删除', 'text-red-400']
        ];
        items.forEach(([action, icon, text, className = '']) => {
            const item = document.createElement('a');
            item.className = `context-menu-item ${className}`;
            item.dataset.action = action;
            item.innerHTML = `<i class="fa ${icon} mr-2"></i>${text}`;
            item.addEventListener('click', () => {
                handleContextMenuAction(action, state.selectedFile);
                hideContextMenu();
            });
            el.contextMenuItems.appendChild(item);
        });
    }
    
    //  隐藏右键菜单
    const hideContextMenu = () => {
        const menu = el.contextMenu;
        if (menu.classList.contains('hidden') && menu.style.display === 'none') return;
        let start = null,
            duration = 150;
        function animate(timestamp) {
            if (!start) start = timestamp;
            const progress = Math.min((timestamp - start) / duration, 1);
            menu.style.opacity = (1 - progress).toString();
            menu.style.transform = `scale(${1 - 0.2 * progress})`;
            if (progress < 1) requestAnimationFrame(animate);
            else {
                menu.classList.add('hidden');
                state.selectedFile = null;
                state.selectedRepo = null;
            }
        }
        requestAnimationFrame(animate);
    };

    //  处理文件右键菜单的点击动作
    function handleContextMenuAction(action, oldFileObject) {
        const currentFile = state.files.find(f => f.path === oldFileObject.path);
        if (!currentFile) {
            showToast('文件已更新，请重新选择或刷新页面');
            return;
        }
        switch (action) {
            case 'download':
                downloadFile(currentFile);
                break;
            case 'copyLink':
                copyLink(currentFile);
                break;
            case 'copyProxy':
                copyProxyLink(currentFile);
                break;
            
            case 'copyGitHubLink':
                navigator.clipboard.writeText(currentFile.html_url).then(() => {
                    showToast('GitHub 链接已复制');
                }).catch(e => {
                    showToast(`复制失败: ${e.message || '请检查浏览器权限或非安全上下文'}`);
                    console.error(e);
                });
                break;

            case 'edit':
                editFile(currentFile);
                break;
            case 'rename':
                showRenameModal(currentFile, currentFile.type === 'dir');
                break;
            case 'delete':
                showDeleteModal(currentFile, currentFile.type === 'dir');
                break;
        }
    }

    //  处理仓库右键菜单的点击动作
    function handleRepoContextMenuAction(action, repo) {
        switch (action) {
            case 'copyRepoGitHubLink':
                navigator.clipboard.writeText(repo.html_url).then(() => {
                    showToast('仓库链接已复制');
                }).catch(e => {
                    showToast(`复制失败: ${e.message || '请检查浏览器权限或非安全上下文'}`);
                    console.error(e);
                });
                break;
            case 'createBranch':
                showCreateBranchModal(repo);
                break;
            case 'downloadRepoDirect':
                downloadRepoAsZip(repo, false);
                break;
            case 'renameRepo':
                showRenameRepoModal(repo);
                break;
            case 'deleteRepo':
                showDeleteRepoModal(repo);
                break;
        }
    }
    
    //  下载仓库的ZIP压缩包
    function downloadRepoAsZip(repo, useProxy) {
        const zipRaw = `https://github.com/${repo.full_name}/archive/refs/heads/${repo.default_branch || 'main'}.zip`;
        const zipUrl = useProxy ? getProxiedUrl(zipRaw) : zipRaw;
        const a = document.createElement('a');
        a.href = zipUrl;
        a.download = `${repo.name}.zip`;
        a.classList.add('hidden');
        document.body.appendChild(a);
        a.click();
        setTimeout(() => document.body.removeChild(a), 500);
        showToast(`正在下载 ${repo.name}.zip (${useProxy ? '代理' : '直连'})`);
    }
    
    //  处理上传按钮的点击事件
    function handleUploadClick() {
        if (!state.currentRepo) {
            showToast('请先选择仓库');
            return;
        }
        el.fileUploadInput.click();
    }
    el.fileUploadInput.addEventListener('change', function(e) {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;
        files.forEach((file, index) => uploadSingleFile(file, index));
    });
    
    //  处理文件选择后的上传逻辑
    function handleFilesSelected(e) {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;
        el.uploadPanel.classList.remove('hidden');
        el.uploadItems.innerHTML = '';
        files.forEach((file, index) => {
            let displayName = file.name;
            if (displayName.length > 25) {
                displayName = displayName.slice(0, 22) + '...';
            }
            const uploadItem = document.createElement('div');
            uploadItem.className = 'upload-item';
            uploadItem.innerHTML = `
                <div class="upload-info">
                    <span class="upload-name" title="${file.name}">${displayName}</span>
                    <span class="upload-size">${formatSize(file.size)}</span>
                </div>
                <div class="upload-progress-container">
                    <div class="upload-progress" data-index="${index}">
                        <span class="percent-text" data-index="${index}">0%</span>
                    </div>
                </div>
                <div class="upload-status" data-index="${index}">等待上传...</div>
            `;
            el.uploadItems.appendChild(uploadItem);
        });
        uploadFilesInSequence(files, 0);
        e.target.value = '';
    }
    
    //  按顺序上传文件队列
    function uploadFilesInSequence(files, index) {
        if (index >= files.length) {
            setTimeout(() => {
                el.uploadPanel.classList.add('hidden');
                fetchFiles(true);
            }, 200);
            return;
        }
        const file = files[index];
        const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
        if (statusElement) statusElement.textContent = '准备上传...';
        uploadSingleFile(file, index)
            .then(() => uploadFilesInSequence(files, index + 1))
            .catch(() => uploadFilesInSequence(files, index + 1));
    }
    
    //  上传单个文件
    async function uploadSingleFile(file, index) {
        const MAX_FILE_SIZE_BYTES = 100 * 1024 * 1024; // GitHub API 限制: 100MB
        return new Promise(async (resolve, reject) => {
            const progressBar = document.querySelector(`.upload-progress[data-index="${index}"]`);
            const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
            const percentTextEl = progressBar.querySelector(`.percent-text[data-index="${index}"]`);
            if (file.size > MAX_FILE_SIZE_BYTES) {
                if (statusElement) {
                    statusElement.textContent = `文件过大，限制100MB`;
                    statusElement.className = 'upload-status error';
                }
                showToast(`文件 "${file.name}" 使用token上传超过100MB官方限制`);
                reject(new Error('文件过大'));
                return;
            }
            if (progressBar) progressBar.style.width = '5%';
            if (statusElement) statusElement.textContent = '正在处理文件...';
            if (percentTextEl) percentTextEl.textContent = '5%';
            const reader = new FileReader();
            reader.readAsArrayBuffer(file);
            reader.onload = async (e) => {
                try {
                    if (statusElement) statusElement.textContent = '正在编码内容...';
                    const base64String = arrayBufferToBase64(e.target.result);
                    if (progressBar) progressBar.style.width = '30%';
                    if (percentTextEl) percentTextEl.textContent = '30%';
                    if (!state || !state.currentRepo) throw new Error('未选择仓库');
                    const fileName = file.name;
                    const filePath = state.currentPath ? `${state.currentPath}${fileName}` : fileName;
                    const [owner, repo] = state.currentRepo.split('/');
                    let existingFileSha = null;
                    try {
                        const checkUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}?ref=${state.currentBranch}`;
                        const checkRes = await fetch(checkUrl, {
                            headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' }
                        });
                        if (checkRes.ok) {
                            const fileData = await checkRes.json();
                            existingFileSha = fileData.sha;
                        } else if (checkRes.status !== 404) {
                            throw new Error(`获取文件信息失败: HTTP ${checkRes.status}`);
                        }
                    } catch (e) {
                        console.warn(`无法获取文件SHA (可能为新文件或网络问题): ${e.message}`);
                    }
                    if (statusElement) statusElement.textContent = '正在上传...';
                    const requestBody = {
                        message: `Upload ${fileName}`,
                        content: base64String,
                        branch: state.currentBranch
                    };
                    if (existingFileSha) {
                        requestBody.sha = existingFileSha;
                    }
                    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${state.token}`,
                            'Content-Type': 'application/json',
                            'User-Agent': 'Mozilla/5.0'
                        },
                        body: JSON.stringify(requestBody),
                        signal: AbortSignal.timeout(180000)
                    });
                    if (progressBar) progressBar.style.width = '100%';
                    if (percentTextEl) percentTextEl.textContent = '100%';
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.message || `上传失败: HTTP ${response.status}`);
                    }
                    if (statusElement) {
                        statusElement.textContent = '上传成功';
                        statusElement.className = 'upload-status success';
                    }
                    resolve();
                } catch (error) {
                    if (statusElement) {
                        statusElement.textContent = '上传失败';
                        statusElement.className = 'upload-status error';
                    }
                    reject(new Error(`上传失败: ${error.message}`));
                }
            };
            reader.onerror = () => {
                if (statusElement) {
                    statusElement.textContent = '文件读取失败';
                    statusElement.className = 'upload-status error';
                }
                showToast(`无法读取文件: ${file.name}`);
                reject(new Error('文件读取失败'));
            };
        });
    }
    
    //  将ArrayBuffer转换为Base64字符串
    function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }
    
    //  显示重命名模态框
    function showRenameModal(item, isDir) {
        const binaryExtensions = ['m3u8','mp3','mp4', 'exe', 'dll', 'so', 'zip', 'rar', '7z', 'gz', 'tar', 'iso', 'bin', 'dat', 'pkg', 'dmg'];
        const imageExtensions = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'];
        const ext = item.name.split('.').pop().toLowerCase();

        if (!isDir && binaryExtensions.includes(ext) && !imageExtensions.includes(ext)) {
            showToast(`不支持此二进制文件重命名`);
            return;
        }

        el.renameTitle.querySelector('.modal-title-text').textContent = `重命名${isDir ? '文件夹' : '文件'}`;
        el.renameInput.value = item.name;
        el.renameWarn.style.display = 'none';
        el.renameWarn.textContent = '';
        el.renameModal.classList.remove('hidden');
        el.renameConfirm.disabled = true;

        el.renameInput.oninput = function() {
            const newName = el.renameInput.value.trim();
            el.renameConfirm.disabled = !newName || newName === item.name;
            if(isDir) {
                const chineseRegex = /[\u4e00-\u9fa5]/;
                if (chineseRegex.test(newName)) {

                    el.renameWarn.style.display = 'block';
                } else {
                    el.renameWarn.style.display = 'none';
                }
            }
        };

        el.renameConfirm.onclick = async function() {
            const v = el.renameInput.value.trim();
            if (!v || v === item.name) return;
            el.renameConfirm.disabled = true;
            el.renameConfirm.classList.add('btn-processing');
            el.renameConfirm.innerHTML = '保存中 <i class="fa fa-spinner fa-spin"></i>';
            try {
                const [owner, repo] = state.currentRepo.split('/');
                const oldPath = item.path;
                const base = oldPath.slice(0, -item.name.length);
                const newPath = base + v;
                if (isDir) {
                    const getAll = async p => {
                        const r = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${p}?ref=${state.currentBranch}`, {
                            headers: {
                                Authorization: `token ${state.token}`
                            }
                        });
                        if (!r.ok) return [];
                        let a = [];
                        for (const i of await r.json()) a.push(...(i.type === 'dir' ? await getAll(i.path) : [i]));
                        return a;
                    };
                    const files = await getAll(oldPath);
                    for (const f of files) {
                        const to = f.path.replace(oldPath, newPath);
                        const d = await (await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${f.path}?ref=${state.currentBranch}`, {
                            headers: {
                                Authorization: `token ${state.token}`
                            }
                        })).json();
                        await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${to}`, {
                            method: 'PUT',
                            headers: {
                                Authorization: `token ${state.token}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                message: `Move ${f.name} to ${newPath}`,
                                content: d.content || '',
                                sha: d.sha,
                                branch: state.currentBranch
                            })
                        });
                    }
                    const filesToDelete = [...files].sort((a, b) => b.path.length - a.path.length);
                    for (const f of filesToDelete) {
                        await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${f.path}`, {
                            method: 'DELETE',
                            headers: {
                                Authorization: `token ${state.token}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                message: `Delete old file ${f.name}`,
                                sha: f.sha,
                                branch: state.currentBranch
                            })
                        });
                    }
                    const resOldFolder = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}?ref=${state.currentBranch}`, {
                        headers: {
                            Authorization: `token ${state.token}`
                        }
                    });
                    if (resOldFolder.ok) {
                        const oldFolderContent = await resOldFolder.json();
                        if (Array.isArray(oldFolderContent) && oldFolderContent.length > 0) {
                            for (const f of oldFolderContent) {
                                if (f.type === 'file') {
                                    await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${f.path}`, {
                                        method: 'DELETE',
                                        headers: {
                                            Authorization: `token ${state.token}`,
                                            'Content-Type': 'application/json'
                                        },
                                        body: JSON.stringify({
                                            message: `Delete old folder stub ${f.name}`,
                                            sha: f.sha,
                                            branch: state.currentBranch
                                        })
                                    });
                                }
                            }
                        }
                    }
                } else {
                    const d = await (await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}?ref=${state.currentBranch}`, {
                        headers: {
                            Authorization: `token ${state.token}`
                        }
                    })).json();
                    await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${newPath}`, {
                        method: 'PUT',
                        headers: {
                            Authorization: `token ${state.token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `Rename to ${v}`,
                            content: d.content,
                            sha: d.sha,
                            branch: state.currentBranch
                        })
                    });
                    await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}`, {
                        method: 'DELETE',
                        headers: {
                            Authorization: `token ${state.token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `Delete old file`,
                            sha: d.sha,
                            branch: state.currentBranch
                        })
                    });
                }
                showToast(`重命名成功: ${v}`);
                el.renameModal.classList.add('hidden');
                fetchFiles(true);
            } catch (e) {
                showToast(`失败: ${e.message}`);
            } finally {
                el.renameConfirm.disabled = false;
                el.renameConfirm.classList.remove('btn-processing');
                el.renameConfirm.innerHTML = '确认';
            }
        };
    }
    
    //  显示新建文件夹模态框
    function showCreateFolderModal() {
        el.createFolderInput.value = '';
        el.createFolderModal.classList.remove('hidden');
        el.createFolderConfirm.disabled = true;
        el.createFolderConfirm.onclick = async function() {
            const name = el.createFolderInput.value.trim();
            if (!name || el.createFolderConfirm.classList.contains('btn-processing')) return;

            el.createFolderConfirm.classList.add('btn-processing');
            el.createFolderConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
            try {
                const [owner, repo] = state.currentRepo.split('/');
                const path = state.currentPath ? `${state.currentPath}${name}` : name;
                await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}/.gitkeep`, {
                    method: 'PUT',
                    headers: {
                        Authorization: `token ${state.token}`,
                        'Content-Type': 'application/json',
                        'User-Agent': 'Mozilla/5.0'
                    },
                    body: JSON.stringify({
                        message: `create folder ${name}`,
                        content: '',
                        branch: state.currentBranch
                    })
                });
                showToast(`已创建文件夹: ${name}`);
                el.createFolderModal.classList.add('hidden');
                fetchFiles(true);
            } catch (e) {
                showToast(`失败: ${e.message}`);
            } finally {
                el.createFolderConfirm.classList.remove('btn-processing');
                el.createFolderConfirm.innerHTML = '确认';
                el.createFolderConfirm.disabled = !el.createFolderInput.value.trim();
            }
        };
    }
    
    //  显示新建文件模态框
    function showCreateFileModal() {
        if (!state.currentRepo) {
            showToast('请先选择仓库');
            return;
        }
        el.createFileNameInput.value = '';
        el.createFileContentInput.value = '';
        el.createFileModal.classList.remove('hidden');
        el.createFileConfirm.disabled = true;
        el.createFileConfirm.onclick = async function() {
            const name = el.createFileNameInput.value.trim();
            const content = el.createFileContentInput.value;
            if (!name) return;
            el.createFileConfirm.disabled = true;
            el.createFileConfirm.classList.add('btn-processing');
            el.createFileConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
            try {
                const [owner, repo] = state.currentRepo.split('/');
                const path = state.currentPath ? `${state.currentPath}${name}` : name;
                const encodedContent = btoa(unescape(encodeURIComponent(content)));
                const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                    method: 'PUT',
                    headers: {
                        Authorization: `token ${state.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: `create file ${name}`,
                        content: encodedContent,
                        branch: state.currentBranch
                    })
                });
                if (!res.ok) throw new Error('创建失败');
                showToast(`已创建文件: ${name}`);
                el.createFileModal.classList.add('hidden');
                fetchFiles(true);
            } catch (e) {
                showToast(`失败: ${e.message}`);
            } finally {
                el.createFileConfirm.disabled = false;
                el.createFileConfirm.classList.remove('btn-processing');
                el.createFileConfirm.innerHTML = '确认';
            }
        };
    }
    
    //  显示新建分支模态框
    // 请使用这个【最终修正版】来完整替换旧的 showCreateBranchModal 函数

async function showCreateBranchModal(repo) {
    el.createBranchNameInput.value = '';
    el.createBranchConfirm.disabled = true;
    el.createBranchSource.innerHTML = '<option>加载中...</option>';
    el.createBranchModal.classList.remove('hidden');

    await fetchBranches(repo);

    el.createBranchSource.innerHTML = '';
    state.branches.forEach(branch => {
        const option = document.createElement('option');
        option.value = branch.name;
        option.textContent = branch.name;
        option.dataset.sha = branch.commit.sha;
        el.createBranchSource.appendChild(option);
    });

    const updateDeleteButtonState = () => {
        const selectedBranch = el.createBranchSource.value;
        if (selectedBranch === repo.default_branch) {
            el.deleteBranchBtn.disabled = true;
            el.deleteBranchBtn.title = '不能删除默认分支';
        } else {
            el.deleteBranchBtn.disabled = false;
            el.deleteBranchBtn.title = `删除分支: ${selectedBranch}`;
        }
    };

    el.createBranchSource.onchange = updateDeleteButtonState;
    updateDeleteButtonState();

    el.deleteBranchBtn.onclick = function() {
        const branchToDelete = el.createBranchSource.value;
        if (branchToDelete === repo.default_branch) {
            showToast('无法删除默认分支');
            return;
        }

        // --- START: 关键修复 ---
        // 1. 在弹出删除框前，先让“新建分支”UI忽略所有鼠标事件
        el.createBranchModal.style.pointerEvents = 'none';
        
        el.deleteTitle.querySelector('.modal-title-text').textContent = '确认删除分支';
        el.deleteDesc.textContent = `确定要删除分支 "${branchToDelete}" 吗？此操作不可撤销。`;
        el.deleteModal.classList.remove('hidden');

        // 封装一个恢复函数，避免重复代码
        const restoreCreateBranchModal = () => {
            el.deleteModal.classList.add('hidden');
            // 2. 无论删除成功还是取消，都要恢复“新建分支”UI的点击事件
            el.createBranchModal.style.pointerEvents = 'auto';
        };

        el.deleteConfirm.onclick = async function() {
            // ... (这里的删除逻辑保持不变)
            const confirmBtn = this;
            confirmBtn.disabled = true;
            confirmBtn.classList.add('btn-processing');
            confirmBtn.innerHTML = '删除中 <i class="fa fa-spinner fa-spin"></i>';
            try {
                const res = await fetch(`https://api.github.com/repos/${repo.full_name}/git/refs/heads/${branchToDelete}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `token ${state.token}` }
                });
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.message || '删除分支失败');
                }
                showToast(`分支 "${branchToDelete}" 已成功删除`);
                
                // 删除成功后，关闭删除框并恢复后台UI
                restoreCreateBranchModal();

                if (state.currentRepo === repo.full_name) {
                    await fetchBranches(repo); 
                    if (branchToDelete === state.currentBranch) {
                        showToast(`当前分支已被删除，切换到默认分支`);
                        state.currentBranch = repo.default_branch;
                        localStorage.setItem(`last_branch_${state.currentRepo}`, state.currentBranch);
                        renderBranchSwitcher();
                        navigateToPath('');
                    } else {
                        renderBranchSwitcher();
                    }
                }
            } catch (e) {
                showToast(`删除失败: ${e.message}`);
            } finally {
                confirmBtn.disabled = false;
                confirmBtn.classList.remove('btn-processing');
                confirmBtn.innerHTML = '确认删除';
                 // 即使失败，也要恢复后台UI
                if(!el.deleteModal.classList.contains('hidden')){
                    restoreCreateBranchModal();
                }
            }
        };
        
        // 3. 当点击取消按钮时，也要恢复后台UI的点击
        el.deleteCancel.onclick = restoreCreateBranchModal;
        // --- END: 关键修复 ---
    };

    el.createBranchConfirm.onclick = async function() {
        // ... (这里的创建分支逻辑保持不变)
        const newBranchName = el.createBranchNameInput.value.trim();
        const sourceBranchOption = el.createBranchSource.selectedOptions[0];
        if (!newBranchName || !sourceBranchOption) return;
        const sourceBranchSha = sourceBranchOption.dataset.sha;
        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}/git/refs`, {
                method: 'POST',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ ref: `refs/heads/${newBranchName}`, sha: sourceBranchSha })
            });
            if (!res.ok) {
                const err = await res.json();
                throw new Error(err.message || '创建分支失败');
            }
            showToast(`分支 "${newBranchName}" 创建成功`);
            el.createBranchModal.classList.add('hidden');
            if (state.currentRepo === repo.full_name) {
                await fetchBranches(repo);
                renderBranchSwitcher();
            }
        } catch (e) {
            showToast(`创建失败: ${e.message}`);
        } finally {
            this.disabled = false;
            this.classList.remove('btn-processing');
            this.innerHTML = '创建分支';
        }
    };
}
    
    //  显示重命名仓库模态框
    function showRenameRepoModal(repo) {
        const renameTitleText = el.renameTitle.querySelector('.modal-title-text');
        renameTitleText.textContent = `重命名仓库: ${repo.name}`;

        el.renameWarn.innerHTML = `<textarea id="newRepoDesc" placeholder="仓库描述（可选）" style="width: 100%; min-height: 70px; margin-top: 10px;">${repo.description || ''}</textarea>`;
        el.renameWarn.style.display = 'block';

        el.renameInput.value = repo.name;
        el.renameConfirm.disabled = true;

        el.renameModal.classList.remove('hidden');

        const descTextarea = document.getElementById('newRepoDesc');
        const updateButtonState = () => {
            const newName = el.renameInput.value.trim();
            const newDesc = descTextarea.value.trim();
            const nameChanged = newName !== repo.name;
            const descChanged = newDesc !== (repo.description || '');
            const isModified = nameChanged || descChanged;
            el.renameConfirm.disabled = !isModified || !newName;
        };

        el.renameInput.oninput = updateButtonState;
        descTextarea.oninput = updateButtonState;

        el.renameConfirm.onclick = async function() {
            const newName = el.renameInput.value.trim();
            const newDesc = descTextarea.value.trim();
            if (newName === repo.name && newDesc === (repo.description || '')) return;

            this.disabled = true;
            this.classList.add('btn-processing');
            this.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';

            try {
                const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `token ${state.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        name: newName,
                        description: newDesc
                    })
                });
                if (!res.ok) throw new Error((await res.json()).message || '修改失败');
                showToast(`保存成功`);
                el.renameModal.classList.add('hidden');
                fetchRepos();
            } catch (e) {
                showToast(`修改失败: ${e.message}`);
            } finally {
                this.disabled = false;
                this.classList.remove('btn-processing');
                this.innerHTML = '确认';
                el.renameWarn.style.display = 'none';
                el.renameWarn.innerHTML = '';
            }
        };
    }
    
    //  显示删除仓库确认模态框
    function showDeleteRepoModal(repo) {
        el.deleteTitle.querySelector('.modal-title-text').textContent = '确认删除仓库';
        el.deleteDesc.textContent = `确定要删除仓库 "${repo.name}" 吗？此操作不可撤销！`;

        el.deleteConfirm.onclick = async function() {
            const confirmBtn = this;
            confirmBtn.disabled = true;
            confirmBtn.classList.add('btn-processing');
            confirmBtn.innerHTML = '删除中 <i class="fa fa-spinner fa-spin"></i>';

            try {
                const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `token ${state.token}`
                    }
                });
                if (!res.ok) throw new Error((await res.json()).message || '删除失败');
                showToast(`仓库 "${repo.name}" 已删除`);
                el.deleteModal.classList.add('hidden');
                fetchRepos();
            } catch (e) {
                showToast(`删除失败: ${e.message}`);
            } finally {
                confirmBtn.disabled = false;
                confirmBtn.classList.remove('btn-processing');
                confirmBtn.innerHTML = '确认删除';
            }
        };
        el.deleteModal.classList.remove('hidden');
    }
    
    //  显示删除文件/文件夹确认模态框
    function showDeleteModal(item, isDir) {
    document.body.appendChild(el.deleteModal); // 将删除确认框移动到文档末尾以确保最高层级
    el.deleteTitle.querySelector('.modal-title-text').textContent = '确认删除';
    el.deleteDesc.textContent = isDir ?
        `确定要删除文件夹 "${item.name}" 吗？这将删除该文件夹及其所有内容。` :
        `确定要删除文件 "${item.name}" 吗？此操作不可撤销。`;
    el.deleteModal.classList.remove('hidden');
    el.deleteConfirm.onclick = async function() {
        const confirmBtn = this;
        confirmBtn.disabled = true;
        confirmBtn.classList.add('btn-processing');
        confirmBtn.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';
        const deleteFile = async (path, sha, name) => {
            const [owner, repo] = state.currentRepo.split('/');
            const res = await fetch(
                `https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                    method: 'DELETE',
                    headers: {
                        Authorization: `token ${state.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: `Delete ${name}`,
                        sha: sha,
                        branch: state.currentBranch
                    })
                }
            );
            if (!res.ok) {
                const errorData = await res.json();
                if (res.status === 409) {
                    throw new Error(`操作冲突：${errorData.message || '请刷新后重试'}`);
                } else {
                    throw new Error(errorData.message || `删除失败 (HTTP ${res.status})`);
                }
            }
        };
        const getAllFiles = async (path) => {
            const [owner, repo] = state.currentRepo.split('/');
            let allFiles = [];
            const res = await fetch(
                `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${state.currentBranch}`, {
                    headers: {
                        Authorization: `token ${state.token}`
                    }
                }
            );
            if (!res.ok) return [];
            const items = await res.json();
            if (!Array.isArray(items)) return [];
            if (items.message && res.status === 404) return [];

            for (const i of items) {
                if (i.type === 'dir') {
                    const subFiles = await getAllFiles(i.path);
                    allFiles = [...allFiles, ...subFiles];
                } else {
                    allFiles.push(i);
                }
            }
            return allFiles;
        };
        try {
            const targetPath = item.path;
            const safeName = escapeHtml(item.name);
            if (isDir) {
                const allFiles = await getAllFiles(targetPath);
                for (const f of allFiles.reverse()) {
                    await deleteFile(f.path, f.sha, f.name);
                }
                showToast(`文件夹"${safeName}"已删除`);
            } else {
                await deleteFile(targetPath, item.sha, item.name);
                showToast(`文件"${safeName}"已删除`);
            }
            el.deleteModal.classList.add('hidden');
            fetchFiles(true);
        } catch (error) {
            showToast(`删除失败: ${error.message}`);
        } finally {
            confirmBtn.disabled = false;
            confirmBtn.classList.remove('btn-processing');
            confirmBtn.innerHTML = '确认删除';
        }
    };
}
    
    //  返回上一级 (通过浏览器历史)
    function goUp() {
        history.back();
    }
    
    //  应用初始化
    async function init() {
    if (state.token) {
        showApp();
        history.replaceState({ repo: null, path: '' }, '', window.location.pathname);
        loadReposFromCache();
        fetchUserInfo();

        // 核心逻辑: 检查“自动优选”设置是否开启
        if (state.autoSelectProxy) {
            // 如果开启了，则在页面加载2秒后执行一次自动优选
            setTimeout(() => findAndSetBestProxy(), 2000);
        } else {
            // 如果没开启，则执行默认行为：使用第一个代理
            if (state.proxies.length > 0) {
                state.activeProxyIndex = 0;
                state.proxyGlobalEnable = true;
            } else {
                state.proxyGlobalEnable = false; // 没有代理就关闭
            }
            saveProxyConfig(); // 保存并更新UI
        }
    } else {
        showAuth();
    }
    setupEventListeners();
}

    document.addEventListener('DOMContentLoaded', init);
    
    //  初始化媒体文件预览功能
    function initMediaPreview() {
    const preview = document.getElementById('mediaPreview');
    const img = document.getElementById('mediaPreviewImg');
    const video = document.getElementById('mediaPreviewVideo');
    const audioExts = ['mp3', 'wav', 'ogg', 'flac', 'm4a'];
    let audioManager = {
        audio: null,
        currentUrl: '',
        currentName: '',
        isPlaying: false,
        init() {
            if (!this.audio) {
                this.audio = new Audio();
                this.audio.preload = 'none';
                this.audio.crossOrigin = 'anonymous';
                this.audio.addEventListener('play', () => {
                    this.isPlaying = true;
                });
                this.audio.addEventListener('pause', () => {
                    this.isPlaying = false;
                });
                this.audio.addEventListener('ended', () => {
                    this.isPlaying = false;
                    showToast(`播放完成: ${this.currentName}`);
                });
                this.audio.addEventListener('error', (e) => {
                    this.isPlaying = false;
                    showToast('播放出错');
                    console.error('Audio error:', e);
                });
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden && this.isPlaying && this.audio.paused) {
                        this.audio.play().catch(() => {});
                    }
                });
            }
        },
        play(url, name) {
            this.init();
            showToast(`正在播放: ${name}`);
            if (this.currentUrl === url) {
                if (this.audio.paused) {
                    this.audio.play().catch(() => {
                        showToast('播放失败');
                    });
                } else {
                    this.audio.pause();
                    showToast(`已暂停: ${name}`);
                }
                return;
            }
            this.currentUrl = url;
            this.currentName = name;
            this.audio.src = url;
            const playPromise = this.audio.play();
            if (playPromise !== undefined) {
                playPromise.catch((error) => {
                    ;
                    console.log('Autoplay prevented:', error);
                });
            }
        }
    };
    preview.onclick = function() {
        if (!preview.classList.contains('hidden')) {
            history.back();
        }
    };
    document.getElementById('fileList').addEventListener('click', function(e) {
        if (e.target.classList.contains('multi-select-checkbox')) return;
        if (e.target.closest('.flex.gap-1,button')) return;
        const item = e.target.closest('.file-item');
        if (!item) return;
        const name = item.querySelector('.file-name') ? item.querySelector('.file-name').textContent : '';
        const ext = name.split('.').pop()?.toLowerCase();
        const file = state.files.find(f => f.name === name);
        if (!file || file.type !== 'file') return;
        const raw = file.download_url ? file.download_url : file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        const url = getProxiedUrl(raw);
        if (audioExts.includes(ext)) {
            const nameWithoutExt = name.substring(0, name.lastIndexOf('.'));
            audioManager.play(url, nameWithoutExt);
            e.imagePreviewAction = true;
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        const openPreview = () => {
            preview.classList.remove('hidden');
            history.pushState({
                mediaPreview: true
            }, 'Media Preview');
            e.imagePreviewAction = true;
            e.preventDefault();
            e.stopPropagation();
        };

        if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'].includes(ext)) {
            img.src = url;
            img.style.display = '';
            video.style.display = 'none';
            openPreview();
            return;
        }
        if (['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'].includes(ext)) {
            video.src = url;
            video.style.display = '';
            img.style.display = 'none';
            openPreview();
            video.load();
            return;
        }
    }, true);
}
    document.addEventListener('DOMContentLoaded', initMediaPreview);
    
    //  显示新建仓库模态框
    function showCreateRepoModal() {
        el.createRepoNameInput.value = '';
        el.createRepoDescInput.value = '';
        el.createRepoPrivate.checked = true;
        el.repoNameError.style.display = 'none';
        el.createRepoModal.classList.remove('hidden');
        el.createRepoConfirm.disabled = true;
        function validateRepoName(name) {
            const chineseRegex = /[\u4e00-\u9fa5]/;
            if (chineseRegex.test(name)) {
                return '仓库名称不能包含中文字符';
            }
            const validNameRegex = /^[a-zA-Z0-9._-]+$/;
            
            
            if (name.length > 100) {
                return '仓库名称不能超过100个字符';
            }
            if (name.startsWith('.') || name.endsWith('.')) {
                return '仓库名称不能以点号开头或结尾';
            }
            return null;
        }
        el.createRepoNameInput.oninput = function() {
    const chineseRegex = /[\u4e00-\u9fa5]/g;
    this.value = this.value.replace(chineseRegex, '');

    const name = el.createRepoNameInput.value.trim();
    const error = validateRepoName(name);
    if (error) {
        el.repoNameError.textContent = error;
        el.repoNameError.style.display = 'block';
        el.createRepoConfirm.disabled = true;
    } else {
        el.repoNameError.style.display = 'none';
        el.createRepoConfirm.disabled = !name;
    }
};
        el.createRepoConfirm.onclick = async function() {
            const name = el.createRepoNameInput.value.trim();
            const description = el.createRepoDescInput.value.trim();
            const isPrivate = !el.createRepoPrivate.checked;
            const error = validateRepoName(name);
            if (error || !name) return;
            el.createRepoConfirm.disabled = true;
            el.createRepoConfirm.classList.add('btn-processing');
            el.createRepoConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
            try {
                const res = await fetch('https://api.github.com/user/repos', {
                    method: 'POST',
                    headers: {
                        'Authorization': `token ${state.token}`,
                        'Content-Type': 'application/json',
                        'User-Agent': 'Mozilla/5.0'
                    },
                    body: JSON.stringify({
                        name: name,
                        description: description || undefined,
                        private: isPrivate,
                        auto_init: true
                    })
                });
                if (!res.ok) {
                    const errorData = await res.json();
                    throw new Error(errorData.message || '创建仓库失败');
                }
                await res.json();
                showToast(`仓库 "${name}" 创建成功`);
                el.createRepoModal.classList.add('hidden');
                fetchRepos();
            } catch (e) {
                showToast(`创建失败: ${e.message}`);
            } finally {
                el.createRepoConfirm.disabled = false;
                el.createRepoConfirm.classList.remove('btn-processing');
                el.createRepoConfirm.innerHTML = '创建仓库';
            }
        };
    }
    document.addEventListener('DOMContentLoaded', function() {
    history.replaceState({
        repo: null,
        path: ''
    }, '', location.href);

    window.addEventListener('popstate', (event) => {
        const preview = document.getElementById('mediaPreview');
        if (!preview.classList.contains('hidden')) {
            preview.classList.add('hidden');
            document.getElementById('mediaPreviewImg').src = '';
            const video = document.getElementById('mediaPreviewVideo');
            video.src = '';
            video.pause();
        }

        const historyState = event.state || {
            repo: null,
            path: ''
        };
        if (historyState.mediaPreview) {
            return;
        }

        state.currentRepo = historyState.repo;
        state.currentPath = historyState.path;
        if (state.currentRepo) {
            const repoData = state.repos.find(r => r.full_name === state.currentRepo);
            if (repoData) {
                state.currentBranch = historyState.branch || repoData.default_branch;
                const repoNameOnly = state.currentRepo.split('/')[1];
                el.currentRepo.textContent = repoNameOnly;
                renderPathNav();
                fetchBranches(repoData).then(() => {
                    renderBranchSwitcher();
                    fetchFiles();
                });
                toggleView(false);
            } else {
                showRepoListView();
            }
        } else {
            showRepoListView();
        }
    });
});
    
    // 自执行 初始化文本编辑器手势控制(缩放字体大小)
    (function() {
        const config = {
            minFontSize: 3,
            maxFontSize: 24,
            defaultFontSize: 10,
            storageKey: 'editor-font-size',
            scaleSensitivity: 0.01
        };
        function getSavedFontSize() {
            const saved = localStorage.getItem(config.storageKey);
            return saved ? parseInt(saved) : config.defaultFontSize;
        }
        function saveFontSize(size) {
            localStorage.setItem(config.storageKey, size);
        }
        function createFontSizeDisplay() {
            const display = document.createElement('div');
            display.style.cssText = `position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; padding: 6px 12px; border-radius: 12px; font-size: 12px; font-weight: bold; z-index: 1000; pointer-events: none; opacity: 0; transition: opacity 0.1s; background-color: rgba(0,0,0,0.5);`;
            return display;
        }
        function showFontSizeTooltip(display, size) {
            display.textContent = `${size}px`;
            display.style.opacity = '1';
            clearTimeout(display.hideTimeout);
            display.hideTimeout = setTimeout(() => {
                display.style.opacity = '0';
            }, 1000);
        }
        function initGestureControls() {
            const observer = new MutationObserver((mutations) => {
                const editModal = document.getElementById('editModal');
                const fileContent = document.getElementById('fileContent');
                const editorContainer = document.querySelector('.editor-container');
                if (editModal && fileContent && editorContainer && !fileContent.hasGestureControl) {
                    fileContent.hasGestureControl = true;
                    let currentSize = getSavedFontSize();
                    fileContent.style.fontSize = currentSize + 'px';
                    fileContent.style.lineHeight = (currentSize * 1.5) + 'px';
                    const fontSizeDisplay = createFontSizeDisplay();
                    editorContainer.appendChild(fontSizeDisplay);
                    let initialDistance = 0;
                    let initialFontSize = currentSize;
                    let isPinching = false;
                    function getTouchDistance(touches) {
                        const dx = touches[0].clientX - touches[1].clientX;
                        const dy = touches[0].clientY - touches[1].clientY;
                        return Math.sqrt(dx * dx + dy * dy);
                    }
                    function updateFontSize(size) {
                        size = Math.max(config.minFontSize, Math.min(config.maxFontSize, Math.round(size)));
                        currentSize = size;
                        fileContent.style.fontSize = size + 'px';
                        fileContent.style.lineHeight = (size * 1.5) + 'px';
                        showFontSizeTooltip(fontSizeDisplay, size);
                        saveFontSize(size);
                    }
                    fileContent.addEventListener('touchstart', (e) => {
                        if (e.touches.length === 2) {
                            e.preventDefault();
                            isPinching = true;
                            initialDistance = getTouchDistance(e.touches);
                            initialFontSize = currentSize;
                        }
                    }, {
                        passive: false
                    });
                    fileContent.addEventListener('touchmove', (e) => {
                        if (isPinching && e.touches.length === 2) {
                            e.preventDefault();
                            const currentDistance = getTouchDistance(e.touches);
                            const scale = currentDistance / initialDistance;
                            const newSize = initialFontSize * scale;
                            updateFontSize(newSize);
                        }
                    }, {
                        passive: false
                    });
                    fileContent.addEventListener('touchend', (e) => {
                        if (isPinching) {
                            isPinching = false;
                        }
                    });
                    fileContent.addEventListener('wheel', (e) => {
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            const delta = e.deltaY > 0 ? -1 : 1;
                            const newSize = currentSize + delta;
                            updateFontSize(newSize);
                        }
                    }, {
                        passive: false
                    });
                    fileContent.addEventListener('keydown', (e) => {
                        if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=')) {
                            e.preventDefault();
                            updateFontSize(currentSize + 1);
                        } else if ((e.ctrlKey || e.metaKey) && e.key === '-') {
                            e.preventDefault();
                            updateFontSize(currentSize - 1);
                        } else if ((e.ctrlKey || e.metaKey) && e.key === '0') {
                            e.preventDefault();
                            updateFontSize(config.defaultFontSize);
                        }
                    });
                    const editModalObserver = new MutationObserver(() => {
                        if (!editModal.classList.contains('hidden')) {
                            currentSize = getSavedFontSize();
                            fileContent.style.fontSize = currentSize + 'px';
                            fileContent.style.lineHeight = (currentSize * 1.5) + 'px';
                        }
                    });
                    editModalObserver.observe(editModal, {
                        attributes: true,
                        attributeFilter: ['class']
                    });
                    const helpText = document.createElement('div');
                    helpText.style.cssText = `position: absolute; bottom: 28px; right: 20px; color: white; font-size: 12px; opacity: 0.8; z-index: 100;`;
                    helpText.innerHTML = '双指缩放调整字体 | Ctrl+滚轮缩放';
                    editorContainer.appendChild(helpText);
                    setTimeout(() => {
                        helpText.style.transition = 'opacity 0.6s';
                        helpText.style.opacity = '0';
                        setTimeout(() => helpText.remove(), 500);
                    }, 10000);
                }
            });
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        }
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initGestureControls);
        } else {
            initGestureControls();
        }
    })();
    
    // 自执行 初始化文本编辑器最大化功能
    (function() {
        'use strict';
        const config = {
            buttonId: 'toggleMaximizeModal',
            modalId: 'editModal',
            closeButtonId: 'closeEditModal',
            maximizedClass: 'maximized',
            expandIcon: 'fa-expand',
            compressIcon: 'fa-compress',
            buttonTitle: {
                maximize: '最大化',
                restore: '恢复',
            },
        };
        let isMaximized = false;
        let maximizeButton = null;
        let editModal = null;
        let isToggling = false;
        let modalObserver = null;
        function createMaximizeButton() {
            const button = document.createElement('button');
            button.id = config.buttonId;
            button.title = config.buttonTitle.maximize;
            button.innerHTML = `<i class="fa ${config.expandIcon}"></i>`;
            return button;
        }
        function toggleMaximize() {
            if (!editModal || !maximizeButton || isToggling) return;
            isToggling = true;
            const icon = maximizeButton.querySelector('i');
            if (isMaximized) {
                editModal.classList.remove(config.maximizedClass);
                icon.classList.remove(config.compressIcon);
                icon.classList.add(config.expandIcon);
                maximizeButton.title = config.buttonTitle.maximize;
                isMaximized = false;
                try {
                    if (typeof window.adjustEditorDimensions === 'function') {
                        setTimeout(window.adjustEditorDimensions, 100);
                    }
                } catch (e) {
                    console.error('调整编辑器尺寸时出错：', e);
                }
            } else {
                editModal.classList.add(config.maximizedClass);
                icon.classList.remove(config.expandIcon);
                icon.classList.add(config.compressIcon);
                maximizeButton.title = config.buttonTitle.restore;
                isMaximized = true;
            }
            try {
                localStorage.setItem('editor-maximized', isMaximized.toString());
            } catch (e) {
                console.error('保存最大化状态失败：', e);
            }
            setTimeout(() => {
                isToggling = false;
            }, 300);
        }
        function restoreMaximizedState() {
            if (isToggling) return;
            try {
                const savedState = localStorage.getItem('editor-maximized') === 'true';
                if (savedState && editModal && !editModal.classList.contains('hidden') && !isMaximized) {
                    toggleMaximize();
                }
            } catch (e) {
                console.error('恢复最大化状态失败：', e);
            }
        }
        function resetMaximizedState() {
            if (isToggling) return;
            if (isMaximized) {
                isMaximized = true;
                toggleMaximize();
            }
        }
        function initializeButton() {
            if (maximizeButton) return;
            if (!editModal) {
                editModal = document.getElementById(config.modalId);
                if (!editModal) return;
            }
            const modalHeader = editModal.querySelector('.modal-header');
            const closeButton = document.getElementById(config.closeButtonId);
            if (!modalHeader || !closeButton) return;
            let buttonContainer = modalHeader.querySelector('div:last-child');
            if (!buttonContainer || buttonContainer.style.display !== 'flex') {
                buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = 'display: flex; gap: 0.4rem;';
                if (closeButton.parentNode === modalHeader) {
                    modalHeader.removeChild(closeButton);
                }
                buttonContainer.appendChild(closeButton);
                modalHeader.appendChild(buttonContainer);
            }
            if (document.getElementById(config.buttonId)) {
                maximizeButton = document.getElementById(config.buttonId);
            } else {
                maximizeButton = createMaximizeButton();
                buttonContainer.insertBefore(maximizeButton, closeButton);
            }
            maximizeButton.removeEventListener('click', toggleMaximize);
            maximizeButton.addEventListener('click', toggleMaximize);
            if (!modalObserver) {
                modalObserver = new MutationObserver((mutations) => {
                    for (let mutation of mutations) {
                        if (mutation.attributeName === 'class') {
                            if (editModal.classList.contains('hidden')) {
                                resetMaximizedState();
                            } else {
                                setTimeout(restoreMaximizedState, 100);
                            }
                        }
                    }
                });
                modalObserver.observe(editModal, {
                    attributes: true,
                    attributeFilter: ['class'],
                });
            }
        }
        function init() {
            const observer = new MutationObserver(() => {
                if (!maximizeButton || !document.getElementById(config.buttonId) || !document.getElementById(config.modalId)) {
                    initializeButton();
                }
            });
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            initializeButton();
            document.addEventListener('keydown', (e) => {
                if (editModal && !editModal.classList.contains('hidden')) {
                    if (e.key === 'F11' || (e.ctrlKey && e.shiftKey && e.key === 'M')) {
                        e.preventDefault();
                        toggleMaximize();
                    }
                }
            });
        }
        init();
    })();
    
    //  打开代理设置模态框
    function openProxySettingsModal() {
        updateProxySettingsUI();
        renderProxyList();
        el.proxySettingsModal.classList.remove('hidden');
        if (!document.getElementById('importBtn')) {
            const btn = document.createElement('button');
            btn.id = 'importBtn';
            btn.className = 'btn-icon';
            btn.title = '导入并刷新所有节点';
            btn.innerHTML = '<i class="fa fa-cloud-download"></i>';
            btn.onclick = () => findAndSetBestProxy(true);
            document.querySelector('#proxySettingsModal .modal-buttons').insertBefore(btn, el.proxyAddBtn);
        }
    }
    
    //  关闭代理设置模态框
    function closeProxySettingsModal() {
        el.proxySettingsModal.classList.add('hidden');
    }
    
    //  更新代理设置面板的UI
    function updateProxySettingsUI() {
        updateProxyToggleUI();
        // 更新自动选择按钮的UI状态
        const isAutoSelectEnabled = !!state.autoSelectProxy;
        el.proxyAutoSelectToggle.classList.toggle('active', isAutoSelectEnabled);
        el.proxyAutoSelectToggle.title = isAutoSelectEnabled ? '自动优选代理已开启' : '自动优选代理已关闭';
    }
    
    //  测试单个代理的连通性和延迟
    async function testProxyConnectivity(proxyDetails) {
       const testRawUrl = PROXY_TEST_URL;
        let proxiedTestUrl = '';
        const proxyInputUrl = (proxyDetails.url || '').trim();
        const proxyDomain = getDomainFromUrl(proxyInputUrl);
        if (!proxyInputUrl) {
            return {
                ok: false,
                ms: null,
                err: 'URL为空',
                type: proxyDetails.type
            };
        }
        if (proxyDetails.type === 'prefix') {
            let base = proxyInputUrl;
            if (!base.endsWith('/')) {
                base += '/';
            }
            proxiedTestUrl = base + testRawUrl;
        } else if (proxyDetails.type === 'raw_domain_replace') {
            proxiedTestUrl = testRawUrl.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
            if (!proxiedTestUrl.startsWith('http')) {
                proxiedTestUrl = 'https://' + proxiedTestUrl;
            }
        } else {
            return {
                ok: false,
                ms: null,
                err: '未知测试类型',
                type: proxyDetails.type
            };
        }
        const start = performance.now();
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 8000); // 8秒超时
            const r = await fetch(proxiedTestUrl, {
                method: 'GET',
                cache: 'no-store',
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (!r.ok) {
                const errorText = await r.text().catch(() => null);
                console.error(`Proxy test failed for ${proxyDetails.url} (${proxyDetails.type}): HTTP ${r.status}, Body: ${errorText}`);
                return {
                    ok: false,
                    ms: null,
                    err: '连接失败 (404)',
                    type: proxyDetails.type
                };
            }
            await r.text();
            return {
                ok: true,
                ms: Math.round(performance.now() - start),
                err: null,
                type: proxyDetails.type
            };
        } catch (e) {
            let errorMsg = '连接失败 (404)';
            if (e.name === 'AbortError') {
                errorMsg = '连接失败 (超时)';
            } else if (e.message.includes('Failed to fetch')) {
                errorMsg = '连接失败 (网络错误)';
            }
            console.error(`Proxy test exception for ${proxyDetails.url} (${proxyDetails.type}): ${e.message}`, e);
            return {
                ok: false,
                ms: null,
                err: errorMsg,
                type: proxyDetails.type
            };
        }
    }
    
    //  自动判断代理类型(前缀/域名替换)并返回最优测试结果
    async function determineBestProxyTypeAndTest(proxyUrl) {
        const results = await Promise.all([
            testProxyConnectivity({
                url: proxyUrl,
                type: 'prefix'
            }),
            testProxyConnectivity({
                url: proxyUrl,
                type: 'raw_domain_replace'
            })
        ]);
        let bestResult = {
            ok: false,
            ms: null,
            err: '所有模式均失败',
            type: null
        };
        let prefixResult = results[0];
        let rawDomainResult = results[1];
        if (prefixResult.ok && rawDomainResult.ok) {
            if (prefixResult.ms < rawDomainResult.ms) {
                bestResult = prefixResult;
            } else {
                bestResult = rawDomainResult;
            }
        } else if (prefixResult.ok) {
            bestResult = prefixResult;
        } else if (rawDomainResult.ok) {
            bestResult = rawDomainResult;
        } else {
            bestResult = prefixResult;
        }
        return bestResult;
    }
    
    //  渲染代理列表到设置面板
    function renderProxyList() {
        el.proxyListContainer.innerHTML = '';
        if (state.proxies.length === 0) {
            el.proxyListEmpty.classList.remove('hidden');
            el.proxyTestAllBtn.disabled = true;
            el.proxyClearAllBtn.disabled = true;
            el.proxyTestAllBtn.classList.add('disabled');
            el.proxyClearAllBtn.classList.add('disabled');
        } else {
            el.proxyListEmpty.classList.add('hidden');
            el.proxyTestAllBtn.disabled = false;
            el.proxyClearAllBtn.disabled = false;
            el.proxyTestAllBtn.classList.remove('disabled');
            el.proxyClearAllBtn.classList.remove('disabled');
        }
        state.proxies.forEach((proxy, index) => {
            const proxyItem = document.createElement('div');
            proxyItem.className = `proxy-item ${index === state.activeProxyIndex ? 'active' : ''}`;
            let latencyClass = 'text-gray-400';
            let latencyText = '未测试';
            if (proxy.status === 'testing') {
                latencyText = '测试中';
                latencyClass = '';
            } else if (proxy.status === 'ok') {
                if (proxy.latency <= 500) {
                    latencyClass = 'text-green-500';
                    latencyText = `${proxy.latency} ms (优)`;
                } else if (proxy.latency <= 2000) {
                    latencyText = `${proxy.latency} ms (中)`;
                    latencyClass = 'text-orange-400';
                } else {
                    latencyText = `${proxy.latency} ms (差)`;
                    latencyClass = 'text-red-400';
                }
            } else if (proxy.status === 'fail') {
                latencyClass = 'text-red-400';
                latencyText = `连接失败 (404)`;
            }
            let typeText = '未知类型';
            if (proxy.type === 'prefix') {
                typeText = '添加前缀';
            } else if (proxy.type === 'raw_domain_replace') {
                typeText = 'raw域名替换';
            } else if (proxy.status === 'testing') {
                typeText = '测试中...';
            } else if (proxy.status === 'fail') {
                typeText = '类型未确定';
            }
            proxyItem.addEventListener('click', (e) => {
                if (e.target.closest('.edit-proxy-btn') || e.target.closest('.delete-proxy-btn')) {
                    return;
                }
                if (index === state.activeProxyIndex) {
                    return;
                }
                setActiveProxy(index);
            });
            proxyItem.innerHTML = `
                    <div class="proxy-info">
                        <div class="proxy-url" title="${proxy.url}">${proxy.url}</div>
                        <div class="proxy-latency ${latencyClass}">${latencyText} ${proxy.status === 'testing' ? '<span class="spinner-small"></span>' : ''}</div>
                        <div class="proxy-type" style="font-size:0.5rem; color:#6b7280; margin-top:0.2rem;">类型: ${typeText}</div>
                    </div>
                    <div class="proxy-actions">
                        <button class="btn-icon-sm edit-proxy-btn" data-index="${index}" title="编辑">
                            <i class="fa fa-pencil"></i>
                        </button>
                        <button class="btn-icon-sm delete-proxy-btn danger" data-index="${index}" title="删除">
                            <i class="fa fa-trash"></i>
                        </button>
                    </div>
                `;
            el.proxyListContainer.appendChild(proxyItem);
        });
        el.proxyListContainer.querySelectorAll('.edit-proxy-btn').forEach(button => {
            button.onclick = (e) => openAddEditProxyModal(parseInt(e.currentTarget.dataset.index));
        });
        el.proxyListContainer.querySelectorAll('.delete-proxy-btn').forEach(button => {
            button.onclick = (e) => showConfirmDeleteProxyModal(parseInt(e.currentTarget.dataset.index));
        });
        saveProxyConfig();
    }
    
    //  保存代理配置到本地存储
    function saveProxyConfig() {
        localStorage.setItem('proxies', JSON.stringify(state.proxies));
        localStorage.setItem('active_proxy_index', JSON.stringify(state.activeProxyIndex));
        localStorage.setItem('proxy_global_enable', JSON.stringify(state.proxyGlobalEnable));
        updateProxyUI();
    }
    
    //  打开添加/编辑代理模态框
    function openAddEditProxyModal(index = null) {
        state.editingProxyIndex = index;
        el.addEditProxyModal.classList.remove('hidden');
        el.addEditProxyUrlInput.value = '';
        el.addEditProxySaveBtn.innerHTML = '保存';
        el.autoDetectedProxyType.textContent = '保存时将自动测试并确定';
        el.addEditProxyError.style.display = 'none';
        const titleTextSpan = el.addEditProxyTitle.querySelector('.modal-title-text');
        if (index !== null && state.proxies[index]) {
            const proxy = state.proxies[index];
            titleTextSpan.textContent = '编辑代理';
            el.addEditProxyUrlInput.value = proxy.url;
            if (proxy.type) {
                 el.autoDetectedProxyType.textContent = proxy.type === 'prefix' ? '添加前缀' : 'raw域名替换';
            }
        } else {
            titleTextSpan.textContent = '添加代理';
        }
        validateAddEditProxyInput();
    }
    
    //  关闭添加/编辑代理模态框
    function closeAddEditProxyModal() {
        el.addEditProxyModal.classList.add('hidden');
        state.editingProxyIndex = null;
        el.addEditProxySaveBtn.disabled = false;
        el.addEditProxySaveBtn.classList.remove('btn-processing');
        el.addEditProxySaveBtn.innerHTML = '保存';
    }
    
    //  验证添加/编辑代理的输入
    function validateAddEditProxyInput() {
        const url = el.addEditProxyUrlInput.value.trim();
        let isValid = true;
        let errorMessage = '';
        if (!url) {
            isValid = false;
        } else {
        let fullUrl = url;
        if (!/^https?:\/\//i.test(fullUrl)) {
            fullUrl = 'https://' + fullUrl;
        }

        const isDuplicate = state.proxies.some((proxy, index) => {
            if (state.editingProxyIndex !== null && index === state.editingProxyIndex) {
                return false;
            }

            let existingUrl = proxy.url;
            if (!/^https?:\/\//i.test(existingUrl)) {
                existingUrl = 'https://' + existingUrl;
            }
            return existingUrl === fullUrl;
        });

        if (isDuplicate) {
            errorMessage = '该代理 URL 已存在';
            isValid = false;
        }
        }
        if (errorMessage) {
            el.addEditProxyError.textContent = errorMessage;
            el.addEditProxyError.style.display = 'block';
        } else {
            el.addEditProxyError.style.display = 'none';
        }
        el.addEditProxySaveBtn.disabled = !isValid;
        return isValid;
    }
    
    //  显示删除代理确认模态框
    function showConfirmDeleteProxyModal(index) {
        const proxy = state.proxies[index];
        el.confirmDeleteProxyTitle.querySelector('.modal-title-text').textContent = '确认删除代理';
        el.confirmDeleteProxyMessage.innerHTML = `确定要删除代理 <strong>"${escapeHtml(proxy.url)}"</strong> 吗？此操作不可撤销。`;
        el.confirmDeleteProxyModal.classList.remove('hidden');
        el.confirmDeleteProxyConfirmBtn.onclick = null;
        el.confirmDeleteProxyCancelBtn.onclick = null;
        el.confirmDeleteProxyConfirmBtn.onclick = async () => {
            el.confirmDeleteProxyConfirmBtn.disabled = true;
            el.confirmDeleteProxyConfirmBtn.classList.add('btn-processing');
            el.confirmDeleteProxyConfirmBtn.innerHTML = `删除中 <span class="spinner-small"></span>`;
            try {
                await deleteProxy(index);
                hideConfirmDeleteProxyModal();
            } finally {
                el.confirmDeleteProxyConfirmBtn.disabled = false;
                el.confirmDeleteProxyConfirmBtn.classList.remove('btn-processing');
                el.confirmDeleteProxyConfirmBtn.innerHTML = '确认删除';
            }
        };
        el.confirmDeleteProxyCancelBtn.onclick = hideConfirmDeleteProxyModal;
    }
    
    //  隐藏删除代理确认模态框
    function hideConfirmDeleteProxyModal() {
        el.confirmDeleteProxyModal.classList.add('hidden');
    }
    
    //  显示清空所有代理确认模态框
    function showConfirmClearAllProxiesModal() {
        el.confirmClearAllProxiesModal.classList.remove('hidden');
        el.clearAllProxiesConfirmBtn.disabled = false;
        el.clearAllProxiesConfirmBtn.innerHTML = '确认清空';
    }
    
    //  隐藏清空所有代理确认模态框
    function hideConfirmClearAllProxiesModal() {
        el.confirmClearAllProxiesModal.classList.add('hidden');
    }
    
    //  确认清空所有代理
    async function clearAllProxiesConfirmed() {
        el.clearAllProxiesConfirmBtn.disabled = true;
        el.clearAllProxiesConfirmBtn.classList.add('btn-processing');
        el.clearAllProxiesConfirmBtn.innerHTML = `清空中 <span class="spinner-small"></span>`;
        state.proxies = [{
            url: "https://gh-proxy.com/",
            latency: null,
            status: null,
            err: null,
            type: null
        }];
        state.activeProxyIndex = 0;
        showToast('所有自定义代理已清空，仅保留默认代理。');
        hideConfirmClearAllProxiesModal();
        renderProxyList();
        await testSingleProxy(0);
        el.clearAllProxiesConfirmBtn.disabled = false;
        el.clearAllProxiesConfirmBtn.classList.remove('btn-processing');
        el.clearAllProxiesConfirmBtn.innerHTML = '确认清空';
    }
    
    //  删除指定索引的代理
    async function deleteProxy(index) {
        state.proxies.splice(index, 1);
        if (state.activeProxyIndex === index) {
            state.activeProxyIndex = state.proxies.length > 0 ? 0 : -1;
        } else if (state.activeProxyIndex > index) {
            state.activeProxyIndex--;
        }
        showToast('代理已删除');
        renderProxyList();
    }
    
    //  设置当前活动的代理
    function setActiveProxy(index) {
        if (index < 0 || index >= state.proxies.length) return;

        state.proxyGlobalEnable = true;

        if (state.activeProxyIndex === index) {
            saveProxyConfig();
            return;
        }

        state.activeProxyIndex = index;
        showToast(`已切换全局代理`);
        renderProxyList();
        if (state.currentRepo) {
            fetchFiles(true);
        }
    }
    
    //  测试单个代理
    async function testSingleProxy(index) {
        if (index < 0 || index >= state.proxies.length) return;
        const proxy = state.proxies[index];
        proxy.status = 'testing';
        proxy.latency = null;
        proxy.err = null;
        proxy.type = null;
        renderProxyList();
        const result = await determineBestProxyTypeAndTest(proxy.url);
        proxy.latency = result.ms;
        proxy.status = result.ok ? 'ok' : 'fail';
        proxy.err = result.err;
        proxy.type = result.type;
        
        renderProxyList();
    }
    
// 函数: 测试所有代理 (修改为分批并行测试，防止UI卡顿)
async function testAllProxies() {
    if (state.proxies.length === 0) {
        showToast('没有代理可供测试');
        return;
    }
    el.proxyTestAllBtn.disabled = true;
    el.proxyTestAllSpinner.classList.remove('hidden');
    
    // 1. 先将所有代理状态设置为 "测试中"，并刷新一次UI
    state.proxies.forEach(proxy => proxy.status = 'testing');
    renderProxyList();

    const proxiesToTest = [...state.proxies];
    const batchSize = 5; // <--- 关键参数：设置每批测试的数量，5是一个比较安全的值
    let testedCount = 0;

    showToast(`开始测试 ${proxiesToTest.length} 个代理...`);

    // 2. 将所有代理分批处理
    for (let i = 0; i < proxiesToTest.length; i += batchSize) {
        const batch = proxiesToTest.slice(i, i + batchSize);
        
        // 3. 对当前批次的代理进行并行测试
        const testPromises = batch.map(proxy => determineBestProxyTypeAndTest(proxy.url));
        const results = await Promise.allSettled(testPromises);

        // 4. 更新当前批次的结果到 state 中
        results.forEach((result, index) => {
            const originalIndex = i + index; // 获取该代理在原始列表中的索引
            if (result.status === 'fulfilled') {
                const data = result.value;
                state.proxies[originalIndex].latency = data.ms;
                state.proxies[originalIndex].status = data.ok ? 'ok' : 'fail';
                state.proxies[originalIndex].err = data.err;
                state.proxies[originalIndex].type = data.type;
            } else {
                state.proxies[originalIndex].status = 'fail';
                state.proxies[originalIndex].err = '测试脚本错误';
            }
        });

        // 5. 每完成一批就刷新一次UI，让用户看到进度
        renderProxyList();
        testedCount += batch.length;
        console.log(`已完成 ${testedCount} / ${proxiesToTest.length} 个代理测试`);
    }

    el.proxyTestAllBtn.disabled = false;
    el.proxyTestAllSpinner.classList.add('hidden');
    showToast('所有代理测试完成');
}
    
    // 函数: 清除应用缓存
    async function clearCache() {
        localStorage.removeItem('cached_repos');
        localStorage.removeItem('repos_cache_time');
        state.fileCache.clear();
        showToast('缓存已清除');
        if (state.currentRepo) {
            await fetchFiles(true);
        } else {
            await fetchRepos();
        }
        el.mainMenuPopup.classList.add('hidden');
    }
    
    // 函数: 寻找并设置延迟最低的代理
    async function findAndSetBestProxy(manual = false) {
        if (manual) {
            showToast('手动导入并测试所有节点…');
        }

        let directConnectResult = { ok: false, ms: Infinity, err: 'N/A' };
        let proxyListText = '';

        try {
            let testRawUrl = PROXY_TEST_URL;
            const start = performance.now();
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 8000);

            const res = await fetch(testRawUrl, { method: 'GET', cache: 'no-store', signal: controller.signal });
            clearTimeout(timeoutId);

            if (res.ok) {
                directConnectResult = { ok: true, ms: Math.round(performance.now() - start), err: null };
                proxyListText = await res.text();
            } else {
                directConnectResult = { ok: false, ms: Infinity, err: `HTTP ${res.status}` };
                if (manual) showToast(`导入失败，无法获取远程列表: ${directConnectResult.err}`);
            }
        } catch (e) {
            let errorMsg = '网络错误';
            if (e.name === 'AbortError') errorMsg = '连接超时';
            directConnectResult = { ok: false, ms: Infinity, err: errorMsg };
            if (manual) showToast(`导入失败: ${errorMsg}`);
        }

        if (proxyListText) {
            const list = proxyListText.split('\n')
                .map(l => l.trim())
                .filter(l => l && !l.startsWith('#') && l.length > 5)
                .filter(u => !state.proxies.some(p => p.url.replace(/\/$/, '') === u.replace(/\/$/, '')));

            if (list.length > 0) {
                const newProxies = list.map(url => ({
                    url,
                    latency: null,
                    status: null,
                    err: null,
                    type: null
                }));
                state.proxies.push(...newProxies);
                state.activeProxyIndex = state.activeProxyIndex < 0 ? 0 : state.activeProxyIndex;
                if (manual) showToast(`成功新增 ${list.length} 个代理`);
            } else {
                if (manual) showToast('无新的代理可导入');
            }
        }
        
        await testAllProxies();
        
        console.log(`直连测试结果: ${directConnectResult.ok ? directConnectResult.ms + 'ms' : directConnectResult.err}`);
        let bestLatency = directConnectResult.ok ? directConnectResult.ms : Infinity;
        let bestChoice = { type: 'direct', index: -1 };

        state.proxies.forEach((proxy, index) => {
            if (proxy.status === 'ok' && proxy.latency < bestLatency) {
                bestLatency = proxy.latency;
                bestChoice = { type: 'proxy', index: index };
            }
        });

        if (bestChoice.type === 'proxy') {
            setActiveProxy(bestChoice.index);
            const bestProxy = state.proxies[bestChoice.index];
            const displayUrl = bestProxy.url.replace(/^https?:\/\//, '').replace(/\/$/, '');
            showToast(`已自动选择最优代理: ${bestProxy.url} ${bestLatency}ms `);
        } else {
            state.proxyGlobalEnable = false;
            localStorage.setItem('proxy_global_enable', 'false');
            updateProxyUI();
            if (bestLatency !== Infinity) {
                showToast(`直连速度最快 (${bestLatency}ms)，未启用代理`);
            } else {
                showToast('所有代理及直连均不可用。');
            }
        }
    }
</script>










</body>
</html>
